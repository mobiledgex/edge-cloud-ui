{"ast":null,"code":"\"use strict\";\n/* eslint-disable no-fallthrough */\n\nvar _slicedToArray = require(\"/Users/kyungjoon/react_pjt/edge-cloud-ui_current-working/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _classCallCheck = require(\"/Users/kyungjoon/react_pjt/edge-cloud-ui_current-working/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/kyungjoon/react_pjt/edge-cloud-ui_current-working/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar ds_1 = require(\"./ds\");\n/**\n * Just a quick overview of what's going on in this file. It's a bit of a mess.\n * Influx uses three time formats:\n *  - ISO times with nanoseconds when querying where an epoch is not provided\n *  - Unix timestamps when querying with an epoch (specifying the precision\n *    in the given time unit)\n *  - Its own time format for time literals.\n *\n * To complicate matters, Influx operates on nanosecond precisions\n * by default, but we can't represent nanosecond timestamps in\n * JavaScript numbers as they're 64 bit uints.\n *\n * As a result we have several utilities to convert between these different\n * formats. When precision is required, we represent nanosecond timestamps\n * as strings and wrap default dates in the INanoDate interface which\n * lets the consumer read and write these more precise timestamps.\n *\n * Representing the timestamps as strings is definitely not a pure way to go\n * about it, but importing an arbitrary-precision integer library adds\n * bloat and is a massive hit to throughput. The operations we do do\n * are pretty trivial, so we stick with manipulating strings\n * and make sure to wash our hands when we're done.\n *\n * Vocabulary:\n *  Unix timestamp   = 'timestamp', abbreviated as 'time'\n *  ISO timestamp    = 'ISO time', abbreviated as 'ISO'\n *  Influx timestamp = 'Influx time', abbreviated as 'Influx'\n */\n\n\nfunction leftPad(str, length) {\n  var pad = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '0';\n\n  if (typeof str === 'number') {\n    str = String(str);\n  }\n\n  while (str.length < length) {\n    str = pad + str;\n  }\n\n  return str;\n}\n\nfunction rightPad(str, length) {\n  var pad = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '0';\n\n  if (typeof str === 'number') {\n    str = String(str);\n  }\n\n  while (str.length < length) {\n    str += pad;\n  }\n\n  return str;\n}\n/**\n * Precision is a map of available Influx time precisions.\n * @type {Object.<String, String>}\n * @example\n * console.log(Precision.Hours); // => 'h'\n * console.log(Precision.Minutes); // => 'm'\n * console.log(Precision.Seconds); // => 's'\n * console.log(Precision.Milliseconds); // => 'ms'\n * console.log(Precision.Microseconds); // => 'u'\n * console.log(Precision.Nanoseconds); // => 'n'\n */\n\n\nexports.Precision = Object.freeze({\n  // Tslint:disable-line\n  Hours: 'h',\n  Microseconds: 'u',\n  Milliseconds: 'ms',\n  Minutes: 'm',\n  Nanoseconds: 'n',\n  Seconds: 's'\n});\n\nvar MillisecondDateManipulator =\n/*#__PURE__*/\nfunction () {\n  function MillisecondDateManipulator() {\n    _classCallCheck(this, MillisecondDateManipulator);\n  }\n\n  _createClass(MillisecondDateManipulator, [{\n    key: \"format\",\n    value: function format(date) {\n      return '\"' + leftPad(date.getUTCFullYear(), 2) + '-' + leftPad(date.getUTCMonth() + 1, 2) + '-' + leftPad(date.getUTCDate(), 2) + ' ' + leftPad(date.getUTCHours(), 2) + ':' + leftPad(date.getUTCMinutes(), 2) + ':' + leftPad(date.getUTCSeconds(), 2) + '.' + leftPad(date.getUTCMilliseconds(), 3) + '\"';\n    }\n  }, {\n    key: \"toTime\",\n    value: function toTime(date, precision) {\n      var ms = date.getTime();\n\n      switch (precision) {\n        case 'n':\n          ms *= 1000;\n\n        case 'u':\n          ms *= 1000;\n\n        case 'ms':\n          return String(ms);\n\n        case 'h':\n          ms /= 60;\n\n        case 'm':\n          ms /= 60;\n\n        case 's':\n          ms /= 1000;\n          return String(Math.floor(ms));\n\n        default:\n          throw new Error(\"Unknown precision '\".concat(precision, \"'!\"));\n      }\n    }\n  }, {\n    key: \"isoToDate\",\n    value: function isoToDate(timestamp) {\n      return new Date(timestamp);\n    }\n  }, {\n    key: \"timetoDate\",\n    value: function timetoDate(timestamp, precision) {\n      switch (precision) {\n        case 'n':\n          timestamp /= 1000;\n\n        case 'u':\n          timestamp /= 1000;\n\n        case 'ms':\n          return new Date(timestamp);\n\n        case 'h':\n          timestamp *= 60;\n\n        case 'm':\n          timestamp *= 60;\n\n        case 's':\n          timestamp *= 1000;\n          return new Date(timestamp);\n\n        default:\n          throw new Error(\"Unknown precision '\".concat(precision, \"'!\"));\n      }\n    }\n  }]);\n\n  return MillisecondDateManipulator;\n}();\n\nvar nsPer = {\n  ms: Math.pow(10, 6),\n  s: Math.pow(10, 9)\n};\n\nfunction nanoIsoToTime(iso) {\n  var _iso$split = iso.split('.'),\n      _iso$split2 = _slicedToArray(_iso$split, 2),\n      secondsStr = _iso$split2[0],\n      decimalStr = _iso$split2[1];\n\n  if (decimalStr === undefined) {\n    decimalStr = '000000000';\n  } else {\n    decimalStr = rightPad(decimalStr.slice(0, -1), 9);\n    secondsStr += 'Z';\n  }\n\n  var seconds = Math.floor(new Date(secondsStr).getTime() / 1000);\n  return \"\".concat(seconds).concat(decimalStr);\n}\n\nvar nanoDateMethods = {\n  getNanoTimeFromISO: function getNanoTimeFromISO() {\n    if (!this._cachedNanoISO) {\n      this._cachedNanoTime = nanoIsoToTime(this._nanoISO);\n    }\n\n    return this._cachedNanoTime;\n  },\n  toNanoISOStringFromISO: function toNanoISOStringFromISO() {\n    if (!this._cachedNanoISO) {\n      this._cachedNanoTime = nanoIsoToTime(this._nanoISO);\n    }\n\n    var base = this.toISOString().slice(0, -4); // Slice of `123Z` milliseconds\n\n    return \"\".concat(base).concat(this._cachedNanoTime.slice(-9), \"Z\");\n  },\n  getNanoTimeFromStamp: function getNanoTimeFromStamp() {\n    return this._nanoTime;\n  },\n  toNanoISOStringFromStamp: function toNanoISOStringFromStamp() {\n    var base = this.toISOString().slice(0, -4); // Slice of `123Z` milliseconds\n\n    return \"\".concat(base).concat(this._nanoTime.slice(-9), \"Z\");\n  }\n};\n/**\n * Covers a nanoseconds unix timestamp to a INanoDate for node-influx. The\n * timestamp is provided as a string to prevent precision loss.\n *\n * Please see [A Moment for Times](https://node-influx.github.io/manual/\n * usage.html#a-moment-for-times) for a more complete and eloquent explanation\n * of time handling in this module.\n *\n * @param timestamp\n * @example\n * const date = toNanoDate('1475985480231035600')\n *\n * // You can use the returned Date as a normal date:\n * expect(date.getTime()).to.equal(1475985480231);\n *\n * // We decorate it with two additional methods to read\n * // nanosecond-precision results:\n * expect(date.getNanoTime()).to.equal('1475985480231035600');\n * expect(date.toNanoISOString()).to.equal('2016-10-09T03:58:00.231035600Z');\n */\n\nfunction toNanoDate(timestamp) {\n  var date = new Date(Math.floor(Number(timestamp) / nsPer.ms));\n  date._nanoTime = timestamp;\n  date.getNanoTime = nanoDateMethods.getNanoTimeFromStamp;\n  date.toNanoISOString = nanoDateMethods.toNanoISOStringFromStamp;\n  return date;\n}\n\nexports.toNanoDate = toNanoDate;\n\nfunction asNanoDate(date) {\n  var d = date;\n\n  if (d.getNanoTime) {\n    return d;\n  }\n\n  return undefined;\n}\n\nvar NanosecondsDateManipulator =\n/*#__PURE__*/\nfunction () {\n  function NanosecondsDateManipulator() {\n    _classCallCheck(this, NanosecondsDateManipulator);\n  }\n\n  _createClass(NanosecondsDateManipulator, [{\n    key: \"format\",\n    value: function format(date) {\n      return '\"' + leftPad(date.getUTCFullYear(), 2) + '-' + leftPad(date.getUTCMonth() + 1, 2) + '-' + leftPad(date.getUTCDate(), 2) + ' ' + leftPad(date.getUTCHours(), 2) + ':' + leftPad(date.getUTCMinutes(), 2) + ':' + leftPad(date.getUTCSeconds(), 2) + '.' + date.getNanoTime().slice(-9) + '\"';\n    }\n  }, {\n    key: \"toTime\",\n    value: function toTime(date, precision) {\n      var ms = date.getTime();\n\n      switch (precision) {\n        case 'u':\n          return date.getNanoTime().slice(0, -3);\n\n        case 'n':\n          return date.getNanoTime();\n\n        case 'h':\n          ms /= 60;\n\n        case 'm':\n          ms /= 60;\n\n        case 's':\n          ms /= 1000;\n\n        case 'ms':\n          return String(Math.floor(ms));\n\n        default:\n          throw new Error(\"Unknown precision '\".concat(precision, \"'!\"));\n      }\n    }\n  }, {\n    key: \"isoToDate\",\n    value: function isoToDate(timestamp) {\n      var date = new Date(timestamp);\n      date._nanoISO = timestamp;\n      date.getNanoTime = nanoDateMethods.getNanoTimeFromISO;\n      date.toNanoISOString = nanoDateMethods.toNanoISOStringFromISO;\n      return date;\n    }\n  }, {\n    key: \"timetoDate\",\n    value: function timetoDate(timestamp, precision) {\n      switch (precision) {\n        case 'h':\n          timestamp *= 60;\n\n        case 'm':\n          timestamp *= 60;\n\n        case 's':\n          timestamp *= 1000;\n\n        case 'ms':\n          timestamp *= 1000;\n\n        case 'u':\n          timestamp *= 1000;\n\n        case 'n':\n          {\n            var date = new Date(timestamp / nsPer.ms);\n            date._nanoTime = String(timestamp);\n            date.getNanoTime = nanoDateMethods.getNanoTimeFromStamp;\n            date.toNanoISOString = nanoDateMethods.toNanoISOStringFromStamp;\n            return date;\n          }\n\n        default:\n          throw new Error(\"Unknown precision '\".concat(precision, \"'!\"));\n      }\n    }\n  }]);\n\n  return NanosecondsDateManipulator;\n}();\n\nvar milliManipulator = new MillisecondDateManipulator();\nvar nanoManipulator = new NanosecondsDateManipulator();\n/**\n * FormatDate converts the Date instance to Influx's date query format.\n * @private\n */\n\nfunction formatDate(date) {\n  var nano = asNanoDate(date);\n\n  if (nano) {\n    return nanoManipulator.format(nano);\n  }\n\n  return milliManipulator.format(date);\n}\n\nexports.formatDate = formatDate;\n/**\n * Converts a Date instance to a timestamp with the specified time precision.\n * @private\n */\n\nfunction dateToTime(date, precision) {\n  var nano = asNanoDate(date);\n\n  if (nano) {\n    return nanoManipulator.toTime(nano, precision);\n  }\n\n  return milliManipulator.toTime(date, precision);\n}\n\nexports.dateToTime = dateToTime;\n/**\n * Converts an ISO-formatted data or unix timestamp to a Date instance. If\n * the precision is finer than 'ms' the returned value will be a INanoDate.\n * @private\n */\n\nfunction isoOrTimeToDate(stamp) {\n  var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'n';\n\n  if (typeof stamp === 'string') {\n    return nanoManipulator.isoToDate(stamp);\n  }\n\n  return nanoManipulator.timetoDate(stamp, precision);\n}\n\nexports.isoOrTimeToDate = isoOrTimeToDate;\n/**\n * Converts a timestamp to a string with the correct precision. Assumes\n * that raw number and string instances are already in the correct precision.\n * @private\n */\n\nfunction castTimestamp(timestamp, precision) {\n  if (typeof timestamp === 'string') {\n    if (!ds_1.isNumeric(timestamp)) {\n      throw new Error(\"Expected numeric value for, timestamp, but got '\".concat(timestamp, \"'!\"));\n    }\n\n    return timestamp;\n  }\n\n  if (typeof timestamp === 'number') {\n    return String(timestamp);\n  }\n\n  return dateToTime(timestamp, precision);\n}\n\nexports.castTimestamp = castTimestamp;","map":{"version":3,"sources":["/Users/kyungjoon/react_pjt/edge-cloud-ui_current-working/node_modules/influx/lib/src/grammar/times.js"],"names":["Object","defineProperty","exports","value","ds_1","require","leftPad","str","length","pad","String","rightPad","Precision","freeze","Hours","Microseconds","Milliseconds","Minutes","Nanoseconds","Seconds","MillisecondDateManipulator","date","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","getUTCMilliseconds","precision","ms","getTime","Math","floor","Error","timestamp","Date","nsPer","pow","s","nanoIsoToTime","iso","split","secondsStr","decimalStr","undefined","slice","seconds","nanoDateMethods","getNanoTimeFromISO","_cachedNanoISO","_cachedNanoTime","_nanoISO","toNanoISOStringFromISO","base","toISOString","getNanoTimeFromStamp","_nanoTime","toNanoISOStringFromStamp","toNanoDate","Number","getNanoTime","toNanoISOString","asNanoDate","d","NanosecondsDateManipulator","milliManipulator","nanoManipulator","formatDate","nano","format","dateToTime","toTime","isoOrTimeToDate","stamp","isoToDate","timetoDate","castTimestamp","isNumeric"],"mappings":"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","sourcesContent":["\"use strict\";\n/* eslint-disable no-fallthrough */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ds_1 = require(\"./ds\");\n/**\n * Just a quick overview of what's going on in this file. It's a bit of a mess.\n * Influx uses three time formats:\n *  - ISO times with nanoseconds when querying where an epoch is not provided\n *  - Unix timestamps when querying with an epoch (specifying the precision\n *    in the given time unit)\n *  - Its own time format for time literals.\n *\n * To complicate matters, Influx operates on nanosecond precisions\n * by default, but we can't represent nanosecond timestamps in\n * JavaScript numbers as they're 64 bit uints.\n *\n * As a result we have several utilities to convert between these different\n * formats. When precision is required, we represent nanosecond timestamps\n * as strings and wrap default dates in the INanoDate interface which\n * lets the consumer read and write these more precise timestamps.\n *\n * Representing the timestamps as strings is definitely not a pure way to go\n * about it, but importing an arbitrary-precision integer library adds\n * bloat and is a massive hit to throughput. The operations we do do\n * are pretty trivial, so we stick with manipulating strings\n * and make sure to wash our hands when we're done.\n *\n * Vocabulary:\n *  Unix timestamp   = 'timestamp', abbreviated as 'time'\n *  ISO timestamp    = 'ISO time', abbreviated as 'ISO'\n *  Influx timestamp = 'Influx time', abbreviated as 'Influx'\n */\nfunction leftPad(str, length, pad = '0') {\n    if (typeof str === 'number') {\n        str = String(str);\n    }\n    while (str.length < length) {\n        str = pad + str;\n    }\n    return str;\n}\nfunction rightPad(str, length, pad = '0') {\n    if (typeof str === 'number') {\n        str = String(str);\n    }\n    while (str.length < length) {\n        str += pad;\n    }\n    return str;\n}\n/**\n * Precision is a map of available Influx time precisions.\n * @type {Object.<String, String>}\n * @example\n * console.log(Precision.Hours); // => 'h'\n * console.log(Precision.Minutes); // => 'm'\n * console.log(Precision.Seconds); // => 's'\n * console.log(Precision.Milliseconds); // => 'ms'\n * console.log(Precision.Microseconds); // => 'u'\n * console.log(Precision.Nanoseconds); // => 'n'\n */\nexports.Precision = Object.freeze({\n    // Tslint:disable-line\n    Hours: 'h',\n    Microseconds: 'u',\n    Milliseconds: 'ms',\n    Minutes: 'm',\n    Nanoseconds: 'n',\n    Seconds: 's'\n});\nclass MillisecondDateManipulator {\n    format(date) {\n        return ('\"' +\n            leftPad(date.getUTCFullYear(), 2) +\n            '-' +\n            leftPad(date.getUTCMonth() + 1, 2) +\n            '-' +\n            leftPad(date.getUTCDate(), 2) +\n            ' ' +\n            leftPad(date.getUTCHours(), 2) +\n            ':' +\n            leftPad(date.getUTCMinutes(), 2) +\n            ':' +\n            leftPad(date.getUTCSeconds(), 2) +\n            '.' +\n            leftPad(date.getUTCMilliseconds(), 3) +\n            '\"');\n    }\n    toTime(date, precision) {\n        let ms = date.getTime();\n        switch (precision) {\n            case 'n':\n                ms *= 1000;\n            case 'u':\n                ms *= 1000;\n            case 'ms':\n                return String(ms);\n            case 'h':\n                ms /= 60;\n            case 'm':\n                ms /= 60;\n            case 's':\n                ms /= 1000;\n                return String(Math.floor(ms));\n            default:\n                throw new Error(`Unknown precision '${precision}'!`);\n        }\n    }\n    isoToDate(timestamp) {\n        return new Date(timestamp);\n    }\n    timetoDate(timestamp, precision) {\n        switch (precision) {\n            case 'n':\n                timestamp /= 1000;\n            case 'u':\n                timestamp /= 1000;\n            case 'ms':\n                return new Date(timestamp);\n            case 'h':\n                timestamp *= 60;\n            case 'm':\n                timestamp *= 60;\n            case 's':\n                timestamp *= 1000;\n                return new Date(timestamp);\n            default:\n                throw new Error(`Unknown precision '${precision}'!`);\n        }\n    }\n}\nconst nsPer = {\n    ms: Math.pow(10, 6),\n    s: Math.pow(10, 9)\n};\nfunction nanoIsoToTime(iso) {\n    let [secondsStr, decimalStr] = iso.split('.');\n    if (decimalStr === undefined) {\n        decimalStr = '000000000';\n    }\n    else {\n        decimalStr = rightPad(decimalStr.slice(0, -1), 9);\n        secondsStr += 'Z';\n    }\n    const seconds = Math.floor(new Date(secondsStr).getTime() / 1000);\n    return `${seconds}${decimalStr}`;\n}\nconst nanoDateMethods = {\n    getNanoTimeFromISO() {\n        if (!this._cachedNanoISO) {\n            this._cachedNanoTime = nanoIsoToTime(this._nanoISO);\n        }\n        return this._cachedNanoTime;\n    },\n    toNanoISOStringFromISO() {\n        if (!this._cachedNanoISO) {\n            this._cachedNanoTime = nanoIsoToTime(this._nanoISO);\n        }\n        const base = this.toISOString().slice(0, -4); // Slice of `123Z` milliseconds\n        return `${base}${this._cachedNanoTime.slice(-9)}Z`;\n    },\n    getNanoTimeFromStamp() {\n        return this._nanoTime;\n    },\n    toNanoISOStringFromStamp() {\n        const base = this.toISOString().slice(0, -4); // Slice of `123Z` milliseconds\n        return `${base}${this._nanoTime.slice(-9)}Z`;\n    }\n};\n/**\n * Covers a nanoseconds unix timestamp to a INanoDate for node-influx. The\n * timestamp is provided as a string to prevent precision loss.\n *\n * Please see [A Moment for Times](https://node-influx.github.io/manual/\n * usage.html#a-moment-for-times) for a more complete and eloquent explanation\n * of time handling in this module.\n *\n * @param timestamp\n * @example\n * const date = toNanoDate('1475985480231035600')\n *\n * // You can use the returned Date as a normal date:\n * expect(date.getTime()).to.equal(1475985480231);\n *\n * // We decorate it with two additional methods to read\n * // nanosecond-precision results:\n * expect(date.getNanoTime()).to.equal('1475985480231035600');\n * expect(date.toNanoISOString()).to.equal('2016-10-09T03:58:00.231035600Z');\n */\nfunction toNanoDate(timestamp) {\n    const date = new Date(Math.floor(Number(timestamp) / nsPer.ms));\n    date._nanoTime = timestamp;\n    date.getNanoTime = nanoDateMethods.getNanoTimeFromStamp;\n    date.toNanoISOString = nanoDateMethods.toNanoISOStringFromStamp;\n    return date;\n}\nexports.toNanoDate = toNanoDate;\nfunction asNanoDate(date) {\n    const d = date;\n    if (d.getNanoTime) {\n        return d;\n    }\n    return undefined;\n}\nclass NanosecondsDateManipulator {\n    format(date) {\n        return ('\"' +\n            leftPad(date.getUTCFullYear(), 2) +\n            '-' +\n            leftPad(date.getUTCMonth() + 1, 2) +\n            '-' +\n            leftPad(date.getUTCDate(), 2) +\n            ' ' +\n            leftPad(date.getUTCHours(), 2) +\n            ':' +\n            leftPad(date.getUTCMinutes(), 2) +\n            ':' +\n            leftPad(date.getUTCSeconds(), 2) +\n            '.' +\n            date.getNanoTime().slice(-9) +\n            '\"');\n    }\n    toTime(date, precision) {\n        let ms = date.getTime();\n        switch (precision) {\n            case 'u':\n                return date.getNanoTime().slice(0, -3);\n            case 'n':\n                return date.getNanoTime();\n            case 'h':\n                ms /= 60;\n            case 'm':\n                ms /= 60;\n            case 's':\n                ms /= 1000;\n            case 'ms':\n                return String(Math.floor(ms));\n            default:\n                throw new Error(`Unknown precision '${precision}'!`);\n        }\n    }\n    isoToDate(timestamp) {\n        const date = new Date(timestamp);\n        date._nanoISO = timestamp;\n        date.getNanoTime = nanoDateMethods.getNanoTimeFromISO;\n        date.toNanoISOString = nanoDateMethods.toNanoISOStringFromISO;\n        return date;\n    }\n    timetoDate(timestamp, precision) {\n        switch (precision) {\n            case 'h':\n                timestamp *= 60;\n            case 'm':\n                timestamp *= 60;\n            case 's':\n                timestamp *= 1000;\n            case 'ms':\n                timestamp *= 1000;\n            case 'u':\n                timestamp *= 1000;\n            case 'n': {\n                const date = new Date(timestamp / nsPer.ms);\n                date._nanoTime = String(timestamp);\n                date.getNanoTime = nanoDateMethods.getNanoTimeFromStamp;\n                date.toNanoISOString = nanoDateMethods.toNanoISOStringFromStamp;\n                return date;\n            }\n            default:\n                throw new Error(`Unknown precision '${precision}'!`);\n        }\n    }\n}\nconst milliManipulator = new MillisecondDateManipulator();\nconst nanoManipulator = new NanosecondsDateManipulator();\n/**\n * FormatDate converts the Date instance to Influx's date query format.\n * @private\n */\nfunction formatDate(date) {\n    const nano = asNanoDate(date);\n    if (nano) {\n        return nanoManipulator.format(nano);\n    }\n    return milliManipulator.format(date);\n}\nexports.formatDate = formatDate;\n/**\n * Converts a Date instance to a timestamp with the specified time precision.\n * @private\n */\nfunction dateToTime(date, precision) {\n    const nano = asNanoDate(date);\n    if (nano) {\n        return nanoManipulator.toTime(nano, precision);\n    }\n    return milliManipulator.toTime(date, precision);\n}\nexports.dateToTime = dateToTime;\n/**\n * Converts an ISO-formatted data or unix timestamp to a Date instance. If\n * the precision is finer than 'ms' the returned value will be a INanoDate.\n * @private\n */\nfunction isoOrTimeToDate(stamp, precision = 'n') {\n    if (typeof stamp === 'string') {\n        return nanoManipulator.isoToDate(stamp);\n    }\n    return nanoManipulator.timetoDate(stamp, precision);\n}\nexports.isoOrTimeToDate = isoOrTimeToDate;\n/**\n * Converts a timestamp to a string with the correct precision. Assumes\n * that raw number and string instances are already in the correct precision.\n * @private\n */\nfunction castTimestamp(timestamp, precision) {\n    if (typeof timestamp === 'string') {\n        if (!ds_1.isNumeric(timestamp)) {\n            throw new Error(`Expected numeric value for, timestamp, but got '${timestamp}'!`);\n        }\n        return timestamp;\n    }\n    if (typeof timestamp === 'number') {\n        return String(timestamp);\n    }\n    return dateToTime(timestamp, precision);\n}\nexports.castTimestamp = castTimestamp;\n"]},"metadata":{},"sourceType":"script"}