{"ast":null,"code":"import { merge } from \"d3-array\";\nimport { geoStream, geoProjection as projection } from \"d3-geo\";\nimport { abs, epsilon, radians } from \"../math\";\n\nfunction pointEqual(a, b) {\n  return abs(a[0] - b[0]) < epsilon && abs(a[1] - b[1]) < epsilon;\n}\n\nfunction interpolateLine(coordinates, m) {\n  var i = -1,\n      n = coordinates.length,\n      p0 = coordinates[0],\n      p1,\n      dx,\n      dy,\n      resampled = [];\n\n  while (++i < n) {\n    p1 = coordinates[i];\n    dx = (p1[0] - p0[0]) / m;\n    dy = (p1[1] - p0[1]) / m;\n\n    for (var j = 0; j < m; ++j) {\n      resampled.push([p0[0] + j * dx, p0[1] + j * dy]);\n    }\n\n    p0 = p1;\n  }\n\n  resampled.push(p1);\n  return resampled;\n}\n\nfunction interpolateSphere(lobes) {\n  var coordinates = [],\n      lobe,\n      lambda0,\n      phi0,\n      phi1,\n      lambda2,\n      phi2,\n      i,\n      n = lobes[0].length; // Northern Hemisphere\n\n  for (i = 0; i < n; ++i) {\n    lobe = lobes[0][i];\n    lambda0 = lobe[0][0], phi0 = lobe[0][1], phi1 = lobe[1][1];\n    lambda2 = lobe[2][0], phi2 = lobe[2][1];\n    coordinates.push(interpolateLine([[lambda0 + epsilon, phi0 + epsilon], [lambda0 + epsilon, phi1 - epsilon], [lambda2 - epsilon, phi1 - epsilon], [lambda2 - epsilon, phi2 + epsilon]], 30));\n  } // Southern Hemisphere\n\n\n  for (i = lobes[1].length - 1; i >= 0; --i) {\n    lobe = lobes[1][i];\n    lambda0 = lobe[0][0], phi0 = lobe[0][1], phi1 = lobe[1][1];\n    lambda2 = lobe[2][0], phi2 = lobe[2][1];\n    coordinates.push(interpolateLine([[lambda2 - epsilon, phi2 - epsilon], [lambda2 - epsilon, phi1 + epsilon], [lambda0 + epsilon, phi1 + epsilon], [lambda0 + epsilon, phi0 - epsilon]], 30));\n  }\n\n  return {\n    type: \"Polygon\",\n    coordinates: [merge(coordinates)]\n  };\n}\n\nexport default function (project, lobes) {\n  var sphere = interpolateSphere(lobes);\n  lobes = lobes.map(function (lobe) {\n    return lobe.map(function (l) {\n      return [[l[0][0] * radians, l[0][1] * radians], [l[1][0] * radians, l[1][1] * radians], [l[2][0] * radians, l[2][1] * radians]];\n    });\n  });\n  var bounds = lobes.map(function (lobe) {\n    return lobe.map(function (l) {\n      var x0 = project(l[0][0], l[0][1])[0],\n          x1 = project(l[2][0], l[2][1])[0],\n          y0 = project(l[1][0], l[0][1])[1],\n          y1 = project(l[1][0], l[1][1])[1],\n          t;\n      if (y0 > y1) t = y0, y0 = y1, y1 = t;\n      return [[x0, y0], [x1, y1]];\n    });\n  });\n\n  function forward(lambda, phi) {\n    var sign = phi < 0 ? -1 : +1,\n        lobe = lobes[+(phi < 0)];\n\n    for (var i = 0, n = lobe.length - 1; i < n && lambda > lobe[i][2][0]; ++i) {\n      ;\n    }\n\n    var p = project(lambda - lobe[i][1][0], phi);\n    p[0] += project(lobe[i][1][0], sign * phi > sign * lobe[i][0][1] ? lobe[i][0][1] : phi)[0];\n    return p;\n  } // Assumes mutually exclusive bounding boxes for lobes.\n\n\n  if (project.invert) forward.invert = function (x, y) {\n    var bound = bounds[+(y < 0)],\n        lobe = lobes[+(y < 0)];\n\n    for (var i = 0, n = bound.length; i < n; ++i) {\n      var b = bound[i];\n\n      if (b[0][0] <= x && x < b[1][0] && b[0][1] <= y && y < b[1][1]) {\n        var p = project.invert(x - project(lobe[i][1][0], 0)[0], y);\n        p[0] += lobe[i][1][0];\n        return pointEqual(forward(p[0], p[1]), [x, y]) ? p : null;\n      }\n    }\n  };\n  var p = projection(forward),\n      stream_ = p.stream;\n\n  p.stream = function (stream) {\n    var rotate = p.rotate(),\n        rotateStream = stream_(stream),\n        sphereStream = (p.rotate([0, 0]), stream_(stream));\n    p.rotate(rotate);\n\n    rotateStream.sphere = function () {\n      geoStream(sphere, sphereStream);\n    };\n\n    return rotateStream;\n  };\n\n  return p;\n}","map":{"version":3,"sources":["/Users/kyungjoon/react_pjt/edge-cloud-ui/node_modules/react-simple-maps/node_modules/d3-geo-projection/src/interrupted/index.js"],"names":["merge","geoStream","geoProjection","projection","abs","epsilon","radians","pointEqual","a","b","interpolateLine","coordinates","m","i","n","length","p0","p1","dx","dy","resampled","j","push","interpolateSphere","lobes","lobe","lambda0","phi0","phi1","lambda2","phi2","type","project","sphere","map","l","bounds","x0","x1","y0","y1","t","forward","lambda","phi","sign","p","invert","x","y","bound","stream_","stream","rotate","rotateStream","sphereStream"],"mappings":"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","sourcesContent":["import {merge} from \"d3-array\";\nimport {geoStream, geoProjection as projection} from \"d3-geo\";\nimport {abs, epsilon, radians} from \"../math\";\n\nfunction pointEqual(a, b) {\n  return abs(a[0] - b[0]) < epsilon && abs(a[1] - b[1]) < epsilon;\n}\n\nfunction interpolateLine(coordinates, m) {\n  var i = -1,\n      n = coordinates.length,\n      p0 = coordinates[0],\n      p1,\n      dx,\n      dy,\n      resampled = [];\n  while (++i < n) {\n    p1 = coordinates[i];\n    dx = (p1[0] - p0[0]) / m;\n    dy = (p1[1] - p0[1]) / m;\n    for (var j = 0; j < m; ++j) resampled.push([p0[0] + j * dx, p0[1] + j * dy]);\n    p0 = p1;\n  }\n  resampled.push(p1);\n  return resampled;\n}\n\nfunction interpolateSphere(lobes) {\n  var coordinates = [],\n      lobe,\n      lambda0, phi0, phi1,\n      lambda2, phi2,\n      i, n = lobes[0].length;\n\n  // Northern Hemisphere\n  for (i = 0; i < n; ++i) {\n    lobe = lobes[0][i];\n    lambda0 = lobe[0][0], phi0 = lobe[0][1], phi1 = lobe[1][1];\n    lambda2 = lobe[2][0], phi2 = lobe[2][1];\n    coordinates.push(interpolateLine([\n      [lambda0 + epsilon, phi0 + epsilon],\n      [lambda0 + epsilon, phi1 - epsilon],\n      [lambda2 - epsilon, phi1 - epsilon],\n      [lambda2 - epsilon, phi2 + epsilon]\n    ], 30));\n  }\n\n  // Southern Hemisphere\n  for (i = lobes[1].length - 1; i >= 0; --i) {\n    lobe = lobes[1][i];\n    lambda0 = lobe[0][0], phi0 = lobe[0][1], phi1 = lobe[1][1];\n    lambda2 = lobe[2][0], phi2 = lobe[2][1];\n    coordinates.push(interpolateLine([\n      [lambda2 - epsilon, phi2 - epsilon],\n      [lambda2 - epsilon, phi1 + epsilon],\n      [lambda0 + epsilon, phi1 + epsilon],\n      [lambda0 + epsilon, phi0 - epsilon]\n    ], 30));\n  }\n\n  return {\n    type: \"Polygon\",\n    coordinates: [merge(coordinates)]\n  };\n}\n\nexport default function(project, lobes) {\n  var sphere = interpolateSphere(lobes);\n\n  lobes = lobes.map(function(lobe) {\n    return lobe.map(function(l) {\n      return [\n        [l[0][0] * radians, l[0][1] * radians],\n        [l[1][0] * radians, l[1][1] * radians],\n        [l[2][0] * radians, l[2][1] * radians]\n      ];\n    });\n  });\n\n  var bounds = lobes.map(function(lobe) {\n    return lobe.map(function(l) {\n      var x0 = project(l[0][0], l[0][1])[0],\n          x1 = project(l[2][0], l[2][1])[0],\n          y0 = project(l[1][0], l[0][1])[1],\n          y1 = project(l[1][0], l[1][1])[1],\n          t;\n      if (y0 > y1) t = y0, y0 = y1, y1 = t;\n      return [[x0, y0], [x1, y1]];\n    });\n  });\n\n  function forward(lambda, phi) {\n    var sign = phi < 0 ? -1 : +1, lobe = lobes[+(phi < 0)];\n    for (var i = 0, n = lobe.length - 1; i < n && lambda > lobe[i][2][0]; ++i);\n    var p = project(lambda - lobe[i][1][0], phi);\n    p[0] += project(lobe[i][1][0], sign * phi > sign * lobe[i][0][1] ? lobe[i][0][1] : phi)[0];\n    return p;\n  }\n\n  // Assumes mutually exclusive bounding boxes for lobes.\n  if (project.invert) forward.invert = function(x, y) {\n    var bound = bounds[+(y < 0)], lobe = lobes[+(y < 0)];\n    for (var i = 0, n = bound.length; i < n; ++i) {\n      var b = bound[i];\n      if (b[0][0] <= x && x < b[1][0] && b[0][1] <= y && y < b[1][1]) {\n        var p = project.invert(x - project(lobe[i][1][0], 0)[0], y);\n        p[0] += lobe[i][1][0];\n        return pointEqual(forward(p[0], p[1]), [x, y]) ? p : null;\n      }\n    }\n  };\n\n  var p = projection(forward),\n      stream_ = p.stream;\n\n  p.stream = function(stream) {\n    var rotate = p.rotate(),\n        rotateStream = stream_(stream),\n        sphereStream = (p.rotate([0, 0]), stream_(stream));\n    p.rotate(rotate);\n    rotateStream.sphere = function() { geoStream(sphere, sphereStream); };\n    return rotateStream;\n  };\n\n  return p;\n}\n"]},"metadata":{},"sourceType":"module"}