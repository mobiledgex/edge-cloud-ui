{"ast":null,"code":"var epsilon = 1e-4,\n    epsilonInverse = 1e4,\n    x0 = -180,\n    x0e = x0 + epsilon,\n    x1 = 180,\n    x1e = x1 - epsilon,\n    y0 = -90,\n    y0e = y0 + epsilon,\n    y1 = 90,\n    y1e = y1 - epsilon;\n\nfunction quantize(x) {\n  return Math.floor(x * epsilonInverse) / epsilonInverse;\n}\n\nfunction normalizePoint(y) {\n  return y === y0 || y === y1 ? [0, y] // pole\n  : [x0, quantize(y)]; // antimeridian\n}\n\nfunction clampPoint(p) {\n  if (p[0] <= x0e) p[0] = x0;else if (p[0] >= x1e) p[0] = x1;\n  if (p[1] <= y0e) p[1] = y0;else if (p[1] >= y1e) p[1] = y1;\n}\n\nfunction clampPoints(points) {\n  points.forEach(clampPoint);\n} // For each ring, detect where it crosses the antimeridian or pole.\n\n\nfunction extractFragments(polygon, fragments) {\n  for (var j = 0, m = polygon.length; j < m; ++j) {\n    var ring = polygon[j];\n    ring.polygon = polygon; // By default, assume that this ring doesn’t need any stitching.\n\n    fragments.push(ring);\n\n    for (var i = 0, n = ring.length; i < n; ++i) {\n      var point = ring[i],\n          x = point[0],\n          y = point[1]; // If this is an antimeridian or polar point…\n\n      if (x <= x0e || x >= x1e || y <= y0e || y >= y1e) {\n        clampPoint(point); // Advance through any antimeridian or polar points…\n\n        for (var k = i + 1; k < n; ++k) {\n          var pointk = ring[k],\n              xk = pointk[0],\n              yk = pointk[1];\n          if (xk > x0e && xk < x1e && yk > y0e && yk < y1e) break;\n        } // If this was just a single antimeridian or polar point,\n        // we don’t need to cut this ring into a fragment;\n        // we can just leave it as-is.\n\n\n        if (k === i + 1) continue; // Otherwise, if this is not the first point in the ring,\n        // cut the current fragment so that it ends at the current point.\n        // The current point is also normalized for later joining.\n\n        if (i) {\n          var fragmentBefore = ring.slice(0, i + 1);\n          fragmentBefore.polygon = polygon;\n          fragmentBefore[fragmentBefore.length - 1] = normalizePoint(y);\n          fragments[fragments.length - 1] = fragmentBefore;\n        } // If the ring started with an antimeridian fragment,\n        // we can ignore that fragment entirely.\n        else fragments.pop(); // If the remainder of the ring is an antimeridian fragment,\n        // move on to the next ring.\n\n\n        if (k >= n) break; // Otherwise, add the remaining ring fragment and continue.\n\n        fragments.push(ring = ring.slice(k - 1));\n        ring[0] = normalizePoint(ring[0][1]);\n        ring.polygon = polygon;\n        i = -1;\n        n = ring.length;\n      }\n    }\n  }\n\n  polygon.length = 0;\n} // Now stitch the fragments back together into rings.\n// TODO remove empty polygons.\n\n\nfunction stitchFragments(fragments) {\n  var i,\n      n = fragments.length; // To connect the fragments start-to-end, create a simple index by end.\n\n  var fragmentByStart = {},\n      fragmentByEnd = {},\n      fragment,\n      start,\n      startFragment,\n      end,\n      endFragment; // For each fragment…\n\n  for (i = 0; i < n; ++i) {\n    fragment = fragments[i];\n    start = fragment[0];\n    end = fragment[fragment.length - 1]; // If this fragment is closed, add it as a standalone ring.\n\n    if (start[0] === end[0] && start[1] === end[1]) {\n      fragment.polygon.push(fragment);\n      fragments[i] = null;\n      continue;\n    }\n\n    fragment.index = i;\n    fragmentByStart[start] = fragmentByEnd[end] = fragment;\n  } // For each open fragment…\n\n\n  for (i = 0; i < n; ++i) {\n    fragment = fragments[i];\n\n    if (fragment) {\n      start = fragment[0];\n      end = fragment[fragment.length - 1];\n      startFragment = fragmentByEnd[start];\n      endFragment = fragmentByStart[end];\n      delete fragmentByStart[start];\n      delete fragmentByEnd[end]; // If this fragment is closed, add it as a standalone ring.\n\n      if (start[0] === end[0] && start[1] === end[1]) {\n        fragment.polygon.push(fragment);\n        continue;\n      }\n\n      if (startFragment) {\n        delete fragmentByEnd[start];\n        delete fragmentByStart[startFragment[0]];\n        startFragment.pop(); // drop the shared coordinate\n\n        fragments[startFragment.index] = null;\n        fragment = startFragment.concat(fragment);\n        fragment.polygon = startFragment.polygon;\n\n        if (startFragment === endFragment) {\n          // Connect both ends to this single fragment to create a ring.\n          fragment.polygon.push(fragment);\n        } else {\n          fragment.index = n++;\n          fragments.push(fragmentByStart[fragment[0]] = fragmentByEnd[fragment[fragment.length - 1]] = fragment);\n        }\n      } else if (endFragment) {\n        delete fragmentByStart[end];\n        delete fragmentByEnd[endFragment[endFragment.length - 1]];\n        fragment.pop(); // drop the shared coordinate\n\n        fragment = fragment.concat(endFragment);\n        fragment.polygon = endFragment.polygon;\n        fragment.index = n++;\n        fragments[endFragment.index] = null;\n        fragments.push(fragmentByStart[fragment[0]] = fragmentByEnd[fragment[fragment.length - 1]] = fragment);\n      } else {\n        fragment.push(fragment[0]); // close ring\n\n        fragment.polygon.push(fragment);\n      }\n    }\n  }\n}\n\nfunction stitchFeature(o) {\n  stitchGeometry(o.geometry);\n}\n\nfunction stitchGeometry(o) {\n  if (!o) return;\n  var fragments, i, n;\n\n  switch (o.type) {\n    case \"GeometryCollection\":\n      {\n        o.geometries.forEach(stitchGeometry);\n        return;\n      }\n\n    case \"Point\":\n      {\n        clampPoint(o.coordinates);\n        break;\n      }\n\n    case \"MultiPoint\":\n    case \"LineString\":\n      {\n        clampPoints(o.coordinates);\n        break;\n      }\n\n    case \"MultiLineString\":\n      {\n        o.coordinates.forEach(clampPoints);\n        break;\n      }\n\n    case \"Polygon\":\n      {\n        extractFragments(o.coordinates, fragments = []);\n        break;\n      }\n\n    case \"MultiPolygon\":\n      {\n        fragments = [], i = -1, n = o.coordinates.length;\n\n        while (++i < n) {\n          extractFragments(o.coordinates[i], fragments);\n        }\n\n        break;\n      }\n\n    default:\n      return;\n  }\n\n  stitchFragments(fragments);\n}\n\nexport default function (o) {\n  if (o) switch (o.type) {\n    case \"Feature\":\n      stitchFeature(o);\n      break;\n\n    case \"FeatureCollection\":\n      o.features.forEach(stitchFeature);\n      break;\n\n    default:\n      stitchGeometry(o);\n      break;\n  }\n  return o;\n}","map":{"version":3,"sources":["/Users/kyungjoon/react_pjt/edge-cloud-ui_current-working/node_modules/react-simple-maps/node_modules/d3-geo-projection/src/stitch.js"],"names":["epsilon","epsilonInverse","x0","x0e","x1","x1e","y0","y0e","y1","y1e","quantize","x","Math","floor","normalizePoint","y","clampPoint","p","clampPoints","points","forEach","extractFragments","polygon","fragments","j","m","length","ring","push","i","n","point","k","pointk","xk","yk","fragmentBefore","slice","pop","stitchFragments","fragmentByStart","fragmentByEnd","fragment","start","startFragment","end","endFragment","index","concat","stitchFeature","o","stitchGeometry","geometry","type","geometries","coordinates","features"],"mappings":"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","sourcesContent":["var epsilon = 1e-4,\n    epsilonInverse = 1e4,\n    x0 = -180, x0e = x0 + epsilon,\n    x1 = 180, x1e = x1 - epsilon,\n    y0 = -90, y0e = y0 + epsilon,\n    y1 = 90, y1e = y1 - epsilon;\n\nfunction quantize(x) {\n  return Math.floor(x * epsilonInverse) / epsilonInverse;\n}\n\nfunction normalizePoint(y) {\n  return y === y0 || y === y1\n      ? [0, y] // pole\n      : [x0, quantize(y)]; // antimeridian\n}\n\nfunction clampPoint(p) {\n  if (p[0] <= x0e) p[0] = x0;\n  else if (p[0] >= x1e) p[0] = x1;\n  if (p[1] <= y0e) p[1] = y0;\n  else if (p[1] >= y1e) p[1] = y1;\n}\n\nfunction clampPoints(points) {\n  points.forEach(clampPoint);\n}\n\n// For each ring, detect where it crosses the antimeridian or pole.\nfunction extractFragments(polygon, fragments) {\n  for (var j = 0, m = polygon.length; j < m; ++j) {\n    var ring = polygon[j];\n    ring.polygon = polygon;\n\n    // By default, assume that this ring doesn’t need any stitching.\n    fragments.push(ring);\n\n    for (var i = 0, n = ring.length; i < n; ++i) {\n      var point = ring[i],\n          x = point[0],\n          y = point[1];\n\n      // If this is an antimeridian or polar point…\n      if (x <= x0e || x >= x1e || y <= y0e || y >= y1e) {\n        clampPoint(point);\n\n        // Advance through any antimeridian or polar points…\n        for (var k = i + 1; k < n; ++k) {\n          var pointk = ring[k],\n              xk = pointk[0],\n              yk = pointk[1];\n          if (xk > x0e && xk < x1e && yk > y0e && yk < y1e) break;\n        }\n\n        // If this was just a single antimeridian or polar point,\n        // we don’t need to cut this ring into a fragment;\n        // we can just leave it as-is.\n        if (k === i + 1) continue;\n\n        // Otherwise, if this is not the first point in the ring,\n        // cut the current fragment so that it ends at the current point.\n        // The current point is also normalized for later joining.\n        if (i) {\n          var fragmentBefore = ring.slice(0, i + 1);\n          fragmentBefore.polygon = polygon;\n          fragmentBefore[fragmentBefore.length - 1] = normalizePoint(y);\n          fragments[fragments.length - 1] = fragmentBefore;\n        }\n\n        // If the ring started with an antimeridian fragment,\n        // we can ignore that fragment entirely.\n        else fragments.pop();\n\n        // If the remainder of the ring is an antimeridian fragment,\n        // move on to the next ring.\n        if (k >= n) break;\n\n        // Otherwise, add the remaining ring fragment and continue.\n        fragments.push(ring = ring.slice(k - 1));\n        ring[0] = normalizePoint(ring[0][1]);\n        ring.polygon = polygon;\n        i = -1;\n        n = ring.length;\n      }\n    }\n  }\n  polygon.length = 0;\n}\n\n// Now stitch the fragments back together into rings.\n// TODO remove empty polygons.\nfunction stitchFragments(fragments) {\n  var i, n = fragments.length;\n\n  // To connect the fragments start-to-end, create a simple index by end.\n  var fragmentByStart = {},\n      fragmentByEnd = {},\n      fragment,\n      start,\n      startFragment,\n      end,\n      endFragment;\n\n  // For each fragment…\n  for (i = 0; i < n; ++i) {\n    fragment = fragments[i];\n    start = fragment[0];\n    end = fragment[fragment.length - 1];\n\n    // If this fragment is closed, add it as a standalone ring.\n    if (start[0] === end[0] && start[1] === end[1]) {\n      fragment.polygon.push(fragment);\n      fragments[i] = null;\n      continue;\n    }\n\n    fragment.index = i;\n    fragmentByStart[start] = fragmentByEnd[end] = fragment;\n  }\n\n  // For each open fragment…\n  for (i = 0; i < n; ++i) {\n    fragment = fragments[i];\n    if (fragment) {\n      start = fragment[0];\n      end = fragment[fragment.length - 1];\n      startFragment = fragmentByEnd[start];\n      endFragment = fragmentByStart[end];\n\n      delete fragmentByStart[start];\n      delete fragmentByEnd[end];\n\n      // If this fragment is closed, add it as a standalone ring.\n      if (start[0] === end[0] && start[1] === end[1]) {\n        fragment.polygon.push(fragment);\n        continue;\n      }\n\n      if (startFragment) {\n        delete fragmentByEnd[start];\n        delete fragmentByStart[startFragment[0]];\n        startFragment.pop(); // drop the shared coordinate\n        fragments[startFragment.index] = null;\n        fragment = startFragment.concat(fragment);\n        fragment.polygon = startFragment.polygon;\n\n        if (startFragment === endFragment) {\n          // Connect both ends to this single fragment to create a ring.\n          fragment.polygon.push(fragment);\n        } else {\n          fragment.index = n++;\n          fragments.push(fragmentByStart[fragment[0]] = fragmentByEnd[fragment[fragment.length - 1]] = fragment);\n        }\n      } else if (endFragment) {\n        delete fragmentByStart[end];\n        delete fragmentByEnd[endFragment[endFragment.length - 1]];\n        fragment.pop(); // drop the shared coordinate\n        fragment = fragment.concat(endFragment);\n        fragment.polygon = endFragment.polygon;\n        fragment.index = n++;\n        fragments[endFragment.index] = null;\n        fragments.push(fragmentByStart[fragment[0]] = fragmentByEnd[fragment[fragment.length - 1]] = fragment);\n      } else {\n        fragment.push(fragment[0]); // close ring\n        fragment.polygon.push(fragment);\n      }\n    }\n  }\n}\n\nfunction stitchFeature(o) {\n  stitchGeometry(o.geometry);\n}\n\nfunction stitchGeometry(o) {\n  if (!o) return;\n  var fragments, i, n;\n\n  switch (o.type) {\n    case \"GeometryCollection\": {\n      o.geometries.forEach(stitchGeometry);\n      return;\n    }\n    case \"Point\": {\n      clampPoint(o.coordinates);\n      break;\n    }\n    case \"MultiPoint\":\n    case \"LineString\": {\n      clampPoints(o.coordinates);\n      break;\n    }\n    case \"MultiLineString\": {\n      o.coordinates.forEach(clampPoints);\n      break;\n    }\n    case \"Polygon\": {\n      extractFragments(o.coordinates, fragments = []);\n      break;\n    }\n    case \"MultiPolygon\": {\n      fragments = [], i = -1, n = o.coordinates.length;\n      while (++i < n) extractFragments(o.coordinates[i], fragments);\n      break;\n    }\n    default: return;\n  }\n\n  stitchFragments(fragments);\n}\n\nexport default function(o) {\n  if (o) switch (o.type) {\n    case \"Feature\": stitchFeature(o); break;\n    case \"FeatureCollection\": o.features.forEach(stitchFeature); break;\n    default: stitchGeometry(o); break;\n  }\n  return o;\n}\n"]},"metadata":{},"sourceType":"module"}