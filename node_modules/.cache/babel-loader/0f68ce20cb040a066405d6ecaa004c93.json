{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/kyungjoon/react_pjt/edge-cloud-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/kyungjoon/react_pjt/edge-cloud-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar grammar_1 = require(\"./grammar\");\n\nfunction regexHasFlags(re) {\n  if (typeof re.flags !== 'undefined') {\n    return re.flags.length > 0;\n  }\n\n  return !re.toString().endsWith('/');\n}\n/**\n * Expression is used to build filtering expressions, like those used in WHERE\n * clauses. It can be used for fluent and safe building of queries using\n * untrusted input.\n *\n * @example\n * e => e\n *   .field('host').equals.value('ares.peet.io')\n *   .or\n *   .field('host').matches(/example\\.com$/)\n *   .or\n *   .expr(e => e\n *     .field('country').equals.value('US')\n *     .and\n *     .field('state').equals.value('WA'));\n *\n * // Generates:\n * // \"host\" = 'ares.peet.io' OR \"host\" ~= /example\\.com$/ OR \\\n * //   (\"county\" = 'US' AND \"state\" = 'WA')\n */\n\n\nvar Expression =\n/*#__PURE__*/\nfunction () {\n  function Expression() {\n    _classCallCheck(this, Expression);\n\n    this._query = [];\n  }\n  /**\n  * Inserts a tag reference into the expression; the name will be\n  * automatically escaped.\n  * @param name\n  * @return\n  */\n\n\n  _createClass(Expression, [{\n    key: \"tag\",\n    value: function tag(name) {\n      this.field(name);\n      return this;\n    }\n    /**\n    * Inserts a field reference into the expression; the name will be\n    * automatically escaped.\n    * @param name\n    * @return\n    */\n\n  }, {\n    key: \"field\",\n    value: function field(name) {\n      this._query.push(grammar_1.escape.quoted(name));\n\n      return this;\n    }\n    /**\n    * Inserts a subexpression; invokes the function with a new expression\n    * that can be chained on.\n    * @param fn\n    * @return\n    * @example\n    * e.field('a').equals.value('b')\n    *   .or.expr(e =>\n    *     e.field('b').equals.value('b')\n    *     .and.field('a').equals.value('c'))\n    *   .toString()\n    * // \"a\" = 'b' OR (\"b\" = 'b' AND \"a\" = 'c')\n    */\n\n  }, {\n    key: \"exp\",\n    value: function exp(fn) {\n      this._query.push('(' + fn(new Expression()).toString() + ')');\n\n      return this;\n    }\n    /**\n    * Value chains on a value to the expression.\n    *\n    *  - Numbers will be inserted verbatim\n    *  - Strings will be escaped and inserted\n    *  - Booleans will be inserted correctly\n    *  - Dates will be formatted and inserted correctly, including INanoDates.\n    *  - Regular expressions will be inserted correctly, however an error will\n    *    be thrown if they contain flags, as regex flags do not work in Influx\n    *  - Otherwise we'll try to call `.toString()` on the value, throwing\n    *    if we cannot do so.\n    *\n    * @param value\n    * @return\n    */\n\n  }, {\n    key: \"value\",\n    value: function value(_value) {\n      switch (typeof _value) {\n        case 'number':\n          this._query.push(_value.toString());\n\n          return this;\n\n        case 'string':\n          this._query.push(grammar_1.escape.stringLit(_value));\n\n          return this;\n\n        case 'boolean':\n          this._query.push(_value ? 'TRUE' : 'FALSE');\n\n          return this;\n\n        default:\n          if (_value instanceof Date) {\n            this._query.push(grammar_1.formatDate(_value));\n\n            return this;\n          }\n\n          if (_value instanceof RegExp) {\n            if (regexHasFlags(_value)) {\n              throw new Error('Attempted to query using a regex with flags, ' + 'but Influx doesn\\'t support flags in queries.');\n            }\n\n            this._query.push('/' + _value.source + '/');\n\n            return this;\n          }\n\n          if (_value && typeof _value.toString === 'function') {\n            this._query.push(_value.toString());\n\n            return this;\n          }\n\n          throw new Error('node-influx doesn\\'t know how to encode the provided value into a ' + 'query. If you think this is a bug, open an issue here: https://git.io/influx-err');\n      }\n    }\n    /**\n    * Chains on an AND clause to the expression.\n    */\n\n  }, {\n    key: \"toString\",\n\n    /**\n    * Converts the expression into its InfluxQL representation.\n    * @return\n    */\n    value: function toString() {\n      return this._query.join(' ');\n    }\n  }, {\n    key: \"and\",\n    get: function get() {\n      this._query.push('AND');\n\n      return this;\n    }\n    /**\n    * Chains on an OR clause to the expression.\n    */\n\n  }, {\n    key: \"or\",\n    get: function get() {\n      this._query.push('OR');\n\n      return this;\n    }\n    /**\n    * Chains on a `+` operator to the expression.\n    */\n\n  }, {\n    key: \"plus\",\n    get: function get() {\n      this._query.push('+');\n\n      return this;\n    }\n    /**\n    * Chains on a `*` operator to the expression.\n    */\n\n  }, {\n    key: \"times\",\n    get: function get() {\n      this._query.push('*');\n\n      return this;\n    }\n    /**\n    * Chains on a `-` operator to the expression.\n    */\n\n  }, {\n    key: \"minus\",\n    get: function get() {\n      this._query.push('-');\n\n      return this;\n    }\n    /**\n    * Chains on a `/` operator to the expression.\n    */\n\n  }, {\n    key: \"div\",\n    get: function get() {\n      this._query.push('/');\n\n      return this;\n    }\n    /**\n    * Chains on a `=` conditional to the expression.\n    */\n\n  }, {\n    key: \"equals\",\n    get: function get() {\n      this._query.push('=');\n\n      return this;\n    }\n    /**\n    * Chains on a `=~` conditional to the expression to match regexes.\n    */\n\n  }, {\n    key: \"matches\",\n    get: function get() {\n      this._query.push('=~');\n\n      return this;\n    }\n    /**\n    * Chains on a `!`` conditional to the expression to match regexes.\n    */\n\n  }, {\n    key: \"doesntMatch\",\n    get: function get() {\n      this._query.push('!~');\n\n      return this;\n    }\n    /**\n    * Chains on a `!=` conditional to the expression.\n    */\n\n  }, {\n    key: \"notEqual\",\n    get: function get() {\n      this._query.push('!=');\n\n      return this;\n    }\n    /**\n    * Chains on a `>` conditional to the expression.\n    */\n\n  }, {\n    key: \"gt\",\n    get: function get() {\n      this._query.push('>');\n\n      return this;\n    }\n    /**\n    * Chains on a `>=` conditional to the expression.\n    */\n\n  }, {\n    key: \"gte\",\n    get: function get() {\n      this._query.push('>=');\n\n      return this;\n    }\n    /**\n    * Chains on a `<` conditional to the expression.\n    */\n\n  }, {\n    key: \"lt\",\n    get: function get() {\n      this._query.push('<');\n\n      return this;\n    }\n    /**\n    * Chains on a `<=` conditional to the expression.\n    */\n\n  }, {\n    key: \"lte\",\n    get: function get() {\n      this._query.push('<=');\n\n      return this;\n    }\n  }]);\n\n  return Expression;\n}();\n\nexports.Expression = Expression;\n/**\n * Measurement creates a reference to a particular measurement. You can\n * reference it solely by its name, but you can also specify the retention\n * policy and database it lives under.\n *\n * @example\n * m.name('my_measurement') // \"my_measurement\"\n * m.name('my_measurement').policy('one_day') // \"one_day\".\"my_measurement\"\n * m.name('my_measurement').policy('one_day').db('mydb') // \"mydb\".\"one_day\".\"my_measurement\"\n */\n\nvar Measurement =\n/*#__PURE__*/\nfunction () {\n  function Measurement() {\n    _classCallCheck(this, Measurement);\n\n    this._parts = [null, null, null];\n  }\n  /**\n  * Sets the measurement name.\n  * @param name\n  * @return\n  */\n\n\n  _createClass(Measurement, [{\n    key: \"name\",\n    value: function name(_name) {\n      this._parts[2] = _name;\n      return this;\n    }\n    /**\n    * Sets the retention policy name.\n    * @param retentionPolicy\n    * @return\n    */\n\n  }, {\n    key: \"policy\",\n    value: function policy(retentionPolicy) {\n      this._parts[1] = retentionPolicy;\n      return this;\n    }\n    /**\n    * Sets the database name.\n    * @param db\n    * @return\n    */\n\n  }, {\n    key: \"db\",\n    value: function db(_db) {\n      this._parts[0] = _db;\n      return this;\n    }\n    /**\n    * Converts the measurement into its InfluxQL representation.\n    * @return\n    * @throws {Error} if a measurement name is not provided\n    */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      if (!this._parts[2]) {\n        throw new Error(\"You must specify a measurement name to query! Got `\".concat(this._parts[2], \"`\"));\n      }\n\n      return this._parts.filter(function (p) {\n        return Boolean(p);\n      }).map(function (p) {\n        return grammar_1.escape.quoted(p);\n      }).join('.');\n    }\n  }]);\n\n  return Measurement;\n}();\n\nexports.Measurement = Measurement;\n\nfunction parseMeasurement(q) {\n  if (typeof q.measurement === 'function') {\n    return q.measurement(new Measurement()).toString();\n  }\n\n  return q.measurement;\n}\n\nexports.parseMeasurement = parseMeasurement;\n\nfunction parseWhere(q) {\n  if (typeof q.where === 'function') {\n    return q.where(new Expression()).toString();\n  }\n\n  return q.where;\n}\n\nexports.parseWhere = parseWhere;","map":{"version":3,"sources":["/Users/kyungjoon/react_pjt/edge-cloud-ui/node_modules/influx/lib/src/builder.js"],"names":["Object","defineProperty","exports","value","grammar_1","require","regexHasFlags","re","flags","length","toString","endsWith","Expression","_query","name","field","push","escape","quoted","fn","stringLit","Date","formatDate","RegExp","Error","source","join","Measurement","_parts","retentionPolicy","db","filter","p","Boolean","map","parseMeasurement","q","measurement","parseWhere","where"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst grammar_1 = require(\"./grammar\");\nfunction regexHasFlags(re) {\n    if (typeof re.flags !== 'undefined') {\n        return re.flags.length > 0;\n    }\n    return !re.toString().endsWith('/');\n}\n/**\n * Expression is used to build filtering expressions, like those used in WHERE\n * clauses. It can be used for fluent and safe building of queries using\n * untrusted input.\n *\n * @example\n * e => e\n *   .field('host').equals.value('ares.peet.io')\n *   .or\n *   .field('host').matches(/example\\.com$/)\n *   .or\n *   .expr(e => e\n *     .field('country').equals.value('US')\n *     .and\n *     .field('state').equals.value('WA'));\n *\n * // Generates:\n * // \"host\" = 'ares.peet.io' OR \"host\" ~= /example\\.com$/ OR \\\n * //   (\"county\" = 'US' AND \"state\" = 'WA')\n */\nclass Expression {\n    constructor() {\n        this._query = [];\n    }\n    /**\n   * Inserts a tag reference into the expression; the name will be\n   * automatically escaped.\n   * @param name\n   * @return\n   */\n    tag(name) {\n        this.field(name);\n        return this;\n    }\n    /**\n   * Inserts a field reference into the expression; the name will be\n   * automatically escaped.\n   * @param name\n   * @return\n   */\n    field(name) {\n        this._query.push(grammar_1.escape.quoted(name));\n        return this;\n    }\n    /**\n   * Inserts a subexpression; invokes the function with a new expression\n   * that can be chained on.\n   * @param fn\n   * @return\n   * @example\n   * e.field('a').equals.value('b')\n   *   .or.expr(e =>\n   *     e.field('b').equals.value('b')\n   *     .and.field('a').equals.value('c'))\n   *   .toString()\n   * // \"a\" = 'b' OR (\"b\" = 'b' AND \"a\" = 'c')\n   */\n    exp(fn) {\n        this._query.push('(' + fn(new Expression()).toString() + ')');\n        return this;\n    }\n    /**\n   * Value chains on a value to the expression.\n   *\n   *  - Numbers will be inserted verbatim\n   *  - Strings will be escaped and inserted\n   *  - Booleans will be inserted correctly\n   *  - Dates will be formatted and inserted correctly, including INanoDates.\n   *  - Regular expressions will be inserted correctly, however an error will\n   *    be thrown if they contain flags, as regex flags do not work in Influx\n   *  - Otherwise we'll try to call `.toString()` on the value, throwing\n   *    if we cannot do so.\n   *\n   * @param value\n   * @return\n   */\n    value(value) {\n        switch (typeof value) {\n            case 'number':\n                this._query.push(value.toString());\n                return this;\n            case 'string':\n                this._query.push(grammar_1.escape.stringLit(value));\n                return this;\n            case 'boolean':\n                this._query.push(value ? 'TRUE' : 'FALSE');\n                return this;\n            default:\n                if (value instanceof Date) {\n                    this._query.push(grammar_1.formatDate(value));\n                    return this;\n                }\n                if (value instanceof RegExp) {\n                    if (regexHasFlags(value)) {\n                        throw new Error('Attempted to query using a regex with flags, ' +\n                            'but Influx doesn\\'t support flags in queries.');\n                    }\n                    this._query.push('/' + value.source + '/');\n                    return this;\n                }\n                if (value && typeof value.toString === 'function') {\n                    this._query.push(value.toString());\n                    return this;\n                }\n                throw new Error('node-influx doesn\\'t know how to encode the provided value into a ' +\n                    'query. If you think this is a bug, open an issue here: https://git.io/influx-err');\n        }\n    }\n    /**\n   * Chains on an AND clause to the expression.\n   */\n    get and() {\n        this._query.push('AND');\n        return this;\n    }\n    /**\n   * Chains on an OR clause to the expression.\n   */\n    get or() {\n        this._query.push('OR');\n        return this;\n    }\n    /**\n   * Chains on a `+` operator to the expression.\n   */\n    get plus() {\n        this._query.push('+');\n        return this;\n    }\n    /**\n   * Chains on a `*` operator to the expression.\n   */\n    get times() {\n        this._query.push('*');\n        return this;\n    }\n    /**\n   * Chains on a `-` operator to the expression.\n   */\n    get minus() {\n        this._query.push('-');\n        return this;\n    }\n    /**\n   * Chains on a `/` operator to the expression.\n   */\n    get div() {\n        this._query.push('/');\n        return this;\n    }\n    /**\n   * Chains on a `=` conditional to the expression.\n   */\n    get equals() {\n        this._query.push('=');\n        return this;\n    }\n    /**\n   * Chains on a `=~` conditional to the expression to match regexes.\n   */\n    get matches() {\n        this._query.push('=~');\n        return this;\n    }\n    /**\n   * Chains on a `!`` conditional to the expression to match regexes.\n   */\n    get doesntMatch() {\n        this._query.push('!~');\n        return this;\n    }\n    /**\n   * Chains on a `!=` conditional to the expression.\n   */\n    get notEqual() {\n        this._query.push('!=');\n        return this;\n    }\n    /**\n   * Chains on a `>` conditional to the expression.\n   */\n    get gt() {\n        this._query.push('>');\n        return this;\n    }\n    /**\n   * Chains on a `>=` conditional to the expression.\n   */\n    get gte() {\n        this._query.push('>=');\n        return this;\n    }\n    /**\n   * Chains on a `<` conditional to the expression.\n   */\n    get lt() {\n        this._query.push('<');\n        return this;\n    }\n    /**\n   * Chains on a `<=` conditional to the expression.\n   */\n    get lte() {\n        this._query.push('<=');\n        return this;\n    }\n    /**\n   * Converts the expression into its InfluxQL representation.\n   * @return\n   */\n    toString() {\n        return this._query.join(' ');\n    }\n}\nexports.Expression = Expression;\n/**\n * Measurement creates a reference to a particular measurement. You can\n * reference it solely by its name, but you can also specify the retention\n * policy and database it lives under.\n *\n * @example\n * m.name('my_measurement') // \"my_measurement\"\n * m.name('my_measurement').policy('one_day') // \"one_day\".\"my_measurement\"\n * m.name('my_measurement').policy('one_day').db('mydb') // \"mydb\".\"one_day\".\"my_measurement\"\n */\nclass Measurement {\n    constructor() {\n        this._parts = [null, null, null];\n    }\n    /**\n   * Sets the measurement name.\n   * @param name\n   * @return\n   */\n    name(name) {\n        this._parts[2] = name;\n        return this;\n    }\n    /**\n   * Sets the retention policy name.\n   * @param retentionPolicy\n   * @return\n   */\n    policy(retentionPolicy) {\n        this._parts[1] = retentionPolicy;\n        return this;\n    }\n    /**\n   * Sets the database name.\n   * @param db\n   * @return\n   */\n    db(db) {\n        this._parts[0] = db;\n        return this;\n    }\n    /**\n   * Converts the measurement into its InfluxQL representation.\n   * @return\n   * @throws {Error} if a measurement name is not provided\n   */\n    toString() {\n        if (!this._parts[2]) {\n            throw new Error(`You must specify a measurement name to query! Got \\`${this._parts[2]}\\``);\n        }\n        return this._parts\n            .filter(p => Boolean(p))\n            .map(p => grammar_1.escape.quoted(p))\n            .join('.');\n    }\n}\nexports.Measurement = Measurement;\nfunction parseMeasurement(q) {\n    if (typeof q.measurement === 'function') {\n        return q.measurement(new Measurement()).toString();\n    }\n    return q.measurement;\n}\nexports.parseMeasurement = parseMeasurement;\nfunction parseWhere(q) {\n    if (typeof q.where === 'function') {\n        return q.where(new Expression()).toString();\n    }\n    return q.where;\n}\nexports.parseWhere = parseWhere;\n"]},"metadata":{},"sourceType":"script"}