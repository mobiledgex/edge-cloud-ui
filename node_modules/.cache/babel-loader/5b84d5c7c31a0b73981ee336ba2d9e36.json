{"ast":null,"code":"import _slicedToArray from \"/Users/kyungjoon/react_pjt/edge-cloud-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n\n/**\n * This file contains some helper functions which are stateless (provide a pure interface)\n * and are used by the timeline component.\n */\n\n/**\n * Differance between two dates\n *\n * @param  {Date} first Date of the first event\n * @param  {Date} second Date of the second event\n * @return {number} Differance between the two dates\n */\nexport var daydiff = function daydiff(first, second) {\n  return Math.round(second - first);\n};\n/**\n * Takes a list of lists and zips them together (size should be the same).\n *\n * e.g. zip([['row0col0', 'row0col1', 'row0col2'], ['row1col0', 'row1col1', 'row1col2']]);\n * = [[\"row0col0\",\"row1col0\"], [\"row0col1\",\"row1col1\"], [\"row0col2\",\"row1col2\"]]\n * @param {array} rows An array (of size 2) of arrays (of equal size).\n * @return {array} An array (of size of either array in param) of arrays (of size 2)\n */\n\nexport var zip = function zip(rows) {\n  return rows[0].map(function (_, c) {\n    return rows.map(function (row) {\n      return row[c];\n    });\n  });\n};\n/**\n * Determines the minimum and maximum distance between a list of dates\n * @param {array} dates The array containing all the dates\n * @return {{min: number, max: number}} The minimum and maximum distances\n */\n\nexport var dateDistanceExtremes = function dateDistanceExtremes(dates) {\n  // determine the minimum distance among events\n  var datePairs = zip([dates.slice(0, -1), dates.slice(1)]);\n  var dateDistances = datePairs.map(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        x = _ref2[0],\n        y = _ref2[1];\n\n    return daydiff(x, y);\n  }); // return the minimum distance between two dates but considering that all dates\n  // are the same then return the provided minimum seperation.\n\n  return {\n    min: Math.min.apply(null, dateDistances),\n    max: Math.max.apply(null, dateDistances)\n  };\n};\n/**\n * @desc : timeline의 간격을 계산처리하는 부분..\n * @param dates\n * @param labelWidth\n * @param minEventPadding\n * @param maxEventPadding\n * @param startPadding\n * @returns {any[]}\n */\n\nexport var cummulativeSeperation = function cummulativeSeperation(dates, labelWidth, minEventPadding, maxEventPadding, startPadding) {\n  var distances = new Array(dates.length);\n  distances[0] = startPadding;\n\n  for (var index = 1; index < distances.length; index += 1) {\n    distances[index] = (index + 1) * labelWidth;\n  }\n\n  return distances;\n};\nexport var return100 = function return100(count) {\n  return 100;\n};","map":{"version":3,"sources":["/Users/kyungjoon/react_pjt/edge-cloud-ui/src/components/horizontal_timeline_kj/helpers.js"],"names":["daydiff","first","second","Math","round","zip","rows","map","_","c","row","dateDistanceExtremes","dates","datePairs","slice","dateDistances","x","y","min","apply","max","cummulativeSeperation","labelWidth","minEventPadding","maxEventPadding","startPadding","distances","Array","length","index","return100","count"],"mappings":";;AAAA;;;;;AAMA;;;;;;;AAOA,OAAO,IAAMA,OAAO,GAAG,SAAVA,OAAU,CAACC,KAAD,EAAQC,MAAR;AAAA,SAAmBC,IAAI,CAACC,KAAL,CAAYF,MAAM,GAAGD,KAArB,CAAnB;AAAA,CAAhB;AAGP;;;;;;;;;AAQA,OAAO,IAAMI,GAAG,GAAG,SAANA,GAAM,CAAAC,IAAI;AAAA,SAAIA,IAAI,CAAC,CAAD,CAAJ,CAAQC,GAAR,CAAY,UAACC,CAAD,EAAIC,CAAJ;AAAA,WAAUH,IAAI,CAACC,GAAL,CAAS,UAAAG,GAAG;AAAA,aAAIA,GAAG,CAACD,CAAD,CAAP;AAAA,KAAZ,CAAV;AAAA,GAAZ,CAAJ;AAAA,CAAhB;AAGP;;;;;;AAKA,OAAO,IAAME,oBAAoB,GAAG,SAAvBA,oBAAuB,CAACC,KAAD,EAAW;AAC3C;AACA,MAAMC,SAAS,GAAGR,GAAG,CAAC,CAACO,KAAK,CAACE,KAAN,CAAY,CAAZ,EAAe,CAAC,CAAhB,CAAD,EAAqBF,KAAK,CAACE,KAAN,CAAY,CAAZ,CAArB,CAAD,CAArB;AACA,MAAMC,aAAa,GAAGF,SAAS,CAACN,GAAV,CAAc;AAAA;AAAA,QAAES,CAAF;AAAA,QAAKC,CAAL;;AAAA,WAAYjB,OAAO,CAACgB,CAAD,EAAIC,CAAJ,CAAnB;AAAA,GAAd,CAAtB,CAH2C,CAK3C;AACA;;AACA,SAAO;AACHC,IAAAA,GAAG,EAAEf,IAAI,CAACe,GAAL,CAASC,KAAT,CAAe,IAAf,EAAqBJ,aAArB,CADF;AAEHK,IAAAA,GAAG,EAAEjB,IAAI,CAACiB,GAAL,CAASD,KAAT,CAAe,IAAf,EAAqBJ,aAArB;AAFF,GAAP;AAIH,CAXM;AAcP;;;;;;;;;;AASA,OAAO,IAAMM,qBAAqB,GAAG,SAAxBA,qBAAwB,CAACT,KAAD,EAAQU,UAAR,EAAoBC,eAApB,EAAqCC,eAArC,EAAsDC,YAAtD,EAAuE;AACxG,MAAMC,SAAS,GAAG,IAAIC,KAAJ,CAAUf,KAAK,CAACgB,MAAhB,CAAlB;AACAF,EAAAA,SAAS,CAAC,CAAD,CAAT,GAAeD,YAAf;;AACA,OAAK,IAAII,KAAK,GAAG,CAAjB,EAAoBA,KAAK,GAAGH,SAAS,CAACE,MAAtC,EAA8CC,KAAK,IAAI,CAAvD,EAA0D;AAEtDH,IAAAA,SAAS,CAACG,KAAD,CAAT,GAAmB,CAACA,KAAK,GAAG,CAAT,IAAcP,UAAjC;AACH;;AACD,SAAOI,SAAP;AACH,CARM;AAUP,OAAO,IAAMI,SAAS,GAAG,SAAZA,SAAY,CAACC,KAAD,EAAmB;AAGxC,SAAO,GAAP;AAGH,CANM","sourcesContent":["/**\n * This file contains some helper functions which are stateless (provide a pure interface)\n * and are used by the timeline component.\n */\n\n\n/**\n * Differance between two dates\n *\n * @param  {Date} first Date of the first event\n * @param  {Date} second Date of the second event\n * @return {number} Differance between the two dates\n */\nexport const daydiff = (first, second) => Math.round((second - first));\n\n\n/**\n * Takes a list of lists and zips them together (size should be the same).\n *\n * e.g. zip([['row0col0', 'row0col1', 'row0col2'], ['row1col0', 'row1col1', 'row1col2']]);\n * = [[\"row0col0\",\"row1col0\"], [\"row0col1\",\"row1col1\"], [\"row0col2\",\"row1col2\"]]\n * @param {array} rows An array (of size 2) of arrays (of equal size).\n * @return {array} An array (of size of either array in param) of arrays (of size 2)\n */\nexport const zip = rows => rows[0].map((_, c) => rows.map(row => row[c]));\n\n\n/**\n * Determines the minimum and maximum distance between a list of dates\n * @param {array} dates The array containing all the dates\n * @return {{min: number, max: number}} The minimum and maximum distances\n */\nexport const dateDistanceExtremes = (dates) => {\n    // determine the minimum distance among events\n    const datePairs = zip([dates.slice(0, -1), dates.slice(1)]);\n    const dateDistances = datePairs.map(([x, y]) => daydiff(x, y));\n\n    // return the minimum distance between two dates but considering that all dates\n    // are the same then return the provided minimum seperation.\n    return {\n        min: Math.min.apply(null, dateDistances),\n        max: Math.max.apply(null, dateDistances)\n    };\n};\n\n\n/**\n * @desc : timeline의 간격을 계산처리하는 부분..\n * @param dates\n * @param labelWidth\n * @param minEventPadding\n * @param maxEventPadding\n * @param startPadding\n * @returns {any[]}\n */\nexport const cummulativeSeperation = (dates, labelWidth, minEventPadding, maxEventPadding, startPadding) => {\n    const distances = new Array(dates.length);\n    distances[0] = startPadding;\n    for (let index = 1; index < distances.length; index += 1) {\n\n        distances[index] = (index + 1) * labelWidth;\n    }\n    return distances;\n};\n\nexport const return100 = (count: number) => {\n\n\n    return 100;\n\n\n}\n"]},"metadata":{},"sourceType":"module"}