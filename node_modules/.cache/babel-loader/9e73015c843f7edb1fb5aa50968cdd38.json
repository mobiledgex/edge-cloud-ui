{"ast":null,"code":"\"use strict\";\n/* eslint-disable @typescript-eslint/unified-signatures */\n\n/* eslint-disable no-dupe-class-members */\n\n/* eslint-disable no-prototype-builtins */\n\nvar _classCallCheck = require(\"/Users/kyungjoon/react_pjt/edge-cloud-ui_current-working/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/kyungjoon/react_pjt/edge-cloud-ui_current-working/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _slicedToArray = require(\"/Users/kyungjoon/react_pjt/edge-cloud-ui_current-working/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nfunction __export(m) {\n  for (var p in m) {\n    if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n  }\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar url = require(\"url\");\n\nvar b = require(\"./builder\");\n\nvar grammar = require(\"./grammar\");\n\nvar pool_1 = require(\"./pool\");\n\nvar results_1 = require(\"./results\");\n\nvar schema_1 = require(\"./schema\");\n\nvar defaultHost = Object.freeze({\n  host: '127.0.0.1',\n  port: 8086,\n  path: '',\n  protocol: 'http'\n});\nvar defaultOptions = Object.freeze({\n  database: null,\n  hosts: [],\n  password: 'root',\n  schema: [],\n  username: 'root'\n});\n\n__export(require(\"./builder\"));\n\nvar grammar_1 = require(\"./grammar\");\n\nexports.FieldType = grammar_1.FieldType;\nexports.Precision = grammar_1.Precision;\nexports.Raw = grammar_1.Raw;\nexports.escape = grammar_1.escape;\nexports.toNanoDate = grammar_1.toNanoDate;\n\nvar results_2 = require(\"./results\");\n\nexports.ResultError = results_2.ResultError;\n/**\n * Parses the URL out into into a IClusterConfig object\n */\n\nfunction parseOptionsUrl(addr) {\n  var parsed = url.parse(addr);\n  var options = {\n    host: parsed.hostname,\n    port: Number(parsed.port),\n    protocol: parsed.protocol.slice(0, -1)\n  };\n\n  if (parsed.auth) {\n    var _parsed$auth$split = parsed.auth.split(':');\n\n    var _parsed$auth$split2 = _slicedToArray(_parsed$auth$split, 2);\n\n    options.username = _parsed$auth$split2[0];\n    options.password = _parsed$auth$split2[1];\n  }\n\n  if (parsed.pathname.length > 1) {\n    options.database = parsed.pathname.slice(1);\n  }\n\n  return options;\n}\n/**\n * Works similarly to Object.assign, but only overwrites\n * properties that resolve to undefined.\n */\n\n\nfunction defaults(target) {\n  for (var _len = arguments.length, srcs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    srcs[_key - 1] = arguments[_key];\n  }\n\n  srcs.forEach(function (src) {\n    Object.keys(src).forEach(function (key) {\n      if (target[key] === undefined) {\n        target[key] = src[key];\n      }\n    });\n  });\n  return target;\n}\n/**\n * InfluxDB is the public interface to run queries against the your database.\n * This is a 'driver-level' module, not a a full-fleged ORM or ODM; you run\n * queries directly by calling methods on this class.\n *\n * Please check out some of [the tutorials](https://node-influx.github.io/manual/tutorial.html)\n * if you want help getting started!\n *\n * @example\n * const Influx = require('influx');\n * const influx = new Influx.InfluxDB({\n *  host: 'localhost',\n *  database: 'express_response_db',\n *  schema: [\n *    {\n *      measurement: 'response_times',\n *      fields: {\n *        path: Influx.FieldType.STRING,\n *        duration: Influx.FieldType.INTEGER\n *      },\n *      tags: [\n *        'host'\n *      ]\n *    }\n *  ]\n * })\n *\n * @example\n * // Connect over HTTPS\n * const Influx = require('influx');\n * const influx = new Influx.InfluxDB({\n *  host: 'myinfluxdbhost',\n *  port: 443,\n *  protocol: 'https'\n *  database: 'express_response_db',\n *  schema: [\n *    {\n *      measurement: 'response_times',\n *      fields: {\n *        path: Influx.FieldType.STRING,\n *        duration: Influx.FieldType.INTEGER\n *      },\n *      tags: [\n *        'host'\n *      ]\n *    }\n *  ]\n * })\n *\n * influx.writePoints([\n *   {\n *     measurement: 'response_times',\n *     tags: { host: os.hostname() },\n *     fields: { duration, path: req.path },\n *   }\n * ]).then(() => {\n *   return influx.query(`\n *     select * from response_times\n *     where host = ${Influx.escape.stringLit(os.hostname())}\n *     order by time desc\n *     limit 10\n *   `)\n * }).then(rows => {\n *   rows.forEach(row => console.log(`A request to ${row.path} took ${row.duration}ms`))\n * })\n */\n\n\nvar InfluxDB =\n/*#__PURE__*/\nfunction () {\n  /**\n  * Connect to a single InfluxDB instance by specifying\n  * a set of connection options.\n  * @param [options='http://root:root@127.0.0.1:8086']\n  *\n  * @example\n  * const Influx = require('influx')\n  *\n  * // Connect to a single host with a DSN:\n  * const influx = new Influx.InfluxDB('http://user:password@host:8086/database')\n  *\n  * @example\n  * const Influx = require('influx')\n  *\n  * // Connect to a single host with a full set of config details and\n  * // a custom schema\n  * const client = new Influx.InfluxDB({\n  *   database: 'my_db',\n  *   host: 'localhost',\n  *   port: 8086,\n  *   username: 'connor',\n  *   password: 'pa$$w0rd',\n  *   schema: [\n  *     {\n  *       measurement: 'perf',\n  *       fields: {\n  *         memory_usage: Influx.FieldType.INTEGER,\n  *         cpu_usage: Influx.FieldType.FLOAT,\n  *         is_online: Influx.FieldType.BOOLEAN\n  *       }\n  *       tags: [\n  *         'hostname'\n  *       ]\n  *     }\n  *   ]\n  * })\n  *\n  * @example\n  * const Influx = require('influx')\n  *\n  * // Use a pool of several host connections and balance queries across them:\n  * const client = new Influx.InfluxDB({\n  *   database: 'my_db',\n  *   username: 'connor',\n  *   password: 'pa$$w0rd',\n  *   hosts: [\n  *     { host: 'db1.example.com' },\n  *     { host: 'db2.example.com' },\n  *   ],\n  *   schema: [\n  *     {\n  *       measurement: 'perf',\n  *       fields: {\n  *         memory_usage: Influx.FieldType.INTEGER,\n  *         cpu_usage: Influx.FieldType.FLOAT,\n  *         is_online: Influx.FieldType.BOOLEAN\n  *       }\n  *       tags: [\n  *         'hostname'\n  *       ]\n  *     }\n  *   ]\n  * })\n  *\n  */\n  function InfluxDB(options) {\n    var _this = this;\n\n    _classCallCheck(this, InfluxDB);\n\n    /**\n    * Map of Schema instances defining measurements in Influx.\n    * @private\n    */\n    this._schema = Object.create(null); // Figure out how to parse whatever we were passed in into a IClusterConfig.\n\n    if (typeof options === 'string') {\n      // Plain URI => ISingleHostConfig\n      options = parseOptionsUrl(options);\n    } else if (!options) {\n      options = defaultHost;\n    }\n\n    if (!options.hasOwnProperty('hosts')) {\n      // ISingleHostConfig => IClusterConfig\n      options = {\n        database: options.database,\n        hosts: [options],\n        password: options.password,\n        pool: options.pool,\n        schema: options.schema,\n        username: options.username\n      };\n    }\n\n    var resolved = options;\n    resolved.hosts = resolved.hosts.map(function (host) {\n      return defaults({\n        host: host.host,\n        port: host.port,\n        path: host.path,\n        protocol: host.protocol,\n        options: host.options\n      }, defaultHost);\n    });\n    this._pool = new pool_1.Pool(resolved.pool);\n    this._options = defaults(resolved, defaultOptions);\n    resolved.hosts.forEach(function (host) {\n      _this._pool.addHost(\"\".concat(host.protocol, \"://\").concat(host.host, \":\").concat(host.port).concat(host.path), host.options);\n    });\n\n    this._options.schema.forEach(function (schema) {\n      return _this._createSchema(schema);\n    });\n  }\n  /**\n  * Adds specified schema for better fields coercing.\n  *\n  * @param {ISchemaOptions} schema\n  * @memberof InfluxDB\n  */\n\n\n  _createClass(InfluxDB, [{\n    key: \"addSchema\",\n    value: function addSchema(schema) {\n      this._createSchema(schema);\n    }\n    /**\n    * Creates a new database with the provided name.\n    * @param databaseName\n    * @return\n    * @example\n    * influx.createDatabase('mydb')\n    */\n\n  }, {\n    key: \"createDatabase\",\n    value: function createDatabase(databaseName) {\n      return this._pool.json(this._getQueryOpts({\n        q: \"create database \".concat(grammar.escape.quoted(databaseName))\n      }, 'POST')).then(results_1.assertNoErrors).then(function () {\n        return undefined;\n      });\n    }\n    /**\n    * Deletes a database with the provided name.\n    * @param databaseName\n    * @return\n    * @example\n    * influx.dropDatabase('mydb')\n    */\n\n  }, {\n    key: \"dropDatabase\",\n    value: function dropDatabase(databaseName) {\n      return this._pool.json(this._getQueryOpts({\n        q: \"drop database \".concat(grammar.escape.quoted(databaseName))\n      }, 'POST')).then(results_1.assertNoErrors).then(function () {\n        return undefined;\n      });\n    }\n    /**\n    * Returns array of database names. Requires cluster admin privileges.\n    * @returns a list of database names\n    * @example\n    * influx.getDatabaseNames().then(names =>\n    *   console.log('My database names are: ' + names.join(', ')));\n    */\n\n  }, {\n    key: \"getDatabaseNames\",\n    value: function getDatabaseNames() {\n      return this._pool.json(this._getQueryOpts({\n        q: 'show databases'\n      })).then(function (res) {\n        return results_1.parseSingle(res).map(function (r) {\n          return r.name;\n        });\n      });\n    }\n    /**\n    * Returns array of measurements.\n    * @returns a list of measurement names\n    * @param [database] the database the measurement lives in, optional\n    *     if a default database is provided.\n    * @example\n    * influx.getMeasurements().then(names =>\n    *   console.log('My measurement names are: ' + names.join(', ')));\n    */\n\n  }, {\n    key: \"getMeasurements\",\n    value: function getMeasurements() {\n      var database = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._defaultDB();\n      return this._pool.json(this._getQueryOpts({\n        db: database,\n        q: 'show measurements'\n      })).then(function (res) {\n        return results_1.parseSingle(res).map(function (r) {\n          return r.name;\n        });\n      });\n    }\n    /**\n    * Returns a list of all series within the target measurement, or from the\n    * entire database if a measurement isn't provided.\n    * @param [options]\n    * @param [options.measurement] if provided, we'll only get series\n    *     from within that measurement.\n    * @param [options.database] the database the series lives in,\n    *     optional if a default database is provided.\n    * @returns a list of series names\n    * @example\n    * influx.getSeries().then(names => {\n    *   console.log('My series names in my_measurement are: ' + names.join(', '))\n    * })\n    *\n    * influx.getSeries({\n    *   measurement: 'my_measurement',\n    *   database: 'my_db'\n    * }).then(names => {\n    *   console.log('My series names in my_measurement are: ' + names.join(', '))\n    * })\n    */\n\n  }, {\n    key: \"getSeries\",\n    value: function getSeries() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var _options$database = options.database,\n          database = _options$database === void 0 ? this._defaultDB() : _options$database,\n          measurement = options.measurement;\n      var query = 'show series';\n\n      if (measurement) {\n        query += \" from \".concat(grammar.escape.quoted(measurement));\n      }\n\n      return this._pool.json(this._getQueryOpts({\n        db: database,\n        q: query\n      })).then(function (res) {\n        return results_1.parseSingle(res).map(function (r) {\n          return r.key;\n        });\n      });\n    }\n    /**\n    * Removes a measurement from the database.\n    * @param measurement\n    * @param [database] the database the measurement lives in, optional\n    *     if a default database is provided.\n    * @return\n    * @example\n    * influx.dropMeasurement('my_measurement')\n    */\n\n  }, {\n    key: \"dropMeasurement\",\n    value: function dropMeasurement(measurement) {\n      var database = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._defaultDB();\n      return this._pool.json(this._getQueryOpts({\n        db: database,\n        q: \"drop measurement \".concat(grammar.escape.quoted(measurement))\n      }, 'POST')).then(results_1.assertNoErrors).then(function () {\n        return undefined;\n      });\n    }\n    /**\n    * Removes a one or more series from InfluxDB.\n    *\n    * @returns\n    * @example\n    * // The following pairs of queries are equivalent: you can chose either to\n    * // use our builder or pass in string directly. The builder takes care\n    * // of escaping and most syntax handling for you.\n    *\n    * influx.dropSeries({ where: e => e.tag('cpu').equals.value('cpu8') })\n    * influx.dropSeries({ where: '\"cpu\" = \\'cpu8\\'' })\n    * // DROP SERIES WHERE \"cpu\" = 'cpu8'\n    *\n    * influx.dropSeries({ measurement: m => m.name('cpu').policy('autogen') })\n    * influx.dropSeries({ measurement: '\"cpu\".\"autogen\"' })\n    * // DROP SERIES FROM \"autogen\".\"cpu\"\n    *\n    * influx.dropSeries({\n    *   measurement: m => m.name('cpu').policy('autogen'),\n    *   where: e => e.tag('cpu').equals.value('cpu8'),\n    *   database: 'my_db'\n    * })\n    * // DROP SERIES FROM \"autogen\".\"cpu\" WHERE \"cpu\" = 'cpu8'\n    */\n\n  }, {\n    key: \"dropSeries\",\n    value: function dropSeries(options) {\n      var db = 'database' in options ? options.database : this._defaultDB();\n      var q = 'drop series';\n\n      if ('measurement' in options) {\n        q += ' from ' + b.parseMeasurement(options);\n      }\n\n      if ('where' in options) {\n        q += ' where ' + b.parseWhere(options);\n      }\n\n      return this._pool.json(this._getQueryOpts({\n        db: db,\n        q: q\n      }, 'POST')).then(results_1.assertNoErrors).then(function () {\n        return undefined;\n      });\n    }\n    /**\n    * Returns a list of users on the Influx database.\n    * @return\n    * @example\n    * influx.getUsers().then(users => {\n    *   users.forEach(user => {\n    *     if (user.admin) {\n    *       console.log(user.user, 'is an admin!')\n    *     } else {\n    *       console.log(user.user, 'is not an admin!')\n    *     }\n    *   })\n    * })\n    */\n\n  }, {\n    key: \"getUsers\",\n    value: function getUsers() {\n      return this._pool.json(this._getQueryOpts({\n        q: 'show users'\n      })).then(function (result) {\n        return results_1.parseSingle(result);\n      });\n    }\n    /**\n    * Creates a new InfluxDB user.\n    * @param username\n    * @param password\n    * @param [admin=false] If true, the user will be given all\n    *     privileges on all databases.\n    * @return\n    * @example\n    * influx.createUser('connor', 'pa55w0rd', true) // make 'connor' an admin\n    *\n    * // make non-admins:\n    * influx.createUser('not_admin', 'pa55w0rd')\n    */\n\n  }, {\n    key: \"createUser\",\n    value: function createUser(username, password) {\n      var admin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      return this._pool.json(this._getQueryOpts({\n        q: \"create user \".concat(grammar.escape.quoted(username), \" with password \") + grammar.escape.stringLit(password) + (admin ? ' with all privileges' : '')\n      }, 'POST')).then(results_1.assertNoErrors).then(function () {\n        return undefined;\n      });\n    }\n    /**\n    * Sets a password for an Influx user.\n    * @param username\n    * @param password\n    * @return\n    * @example\n    * influx.setPassword('connor', 'pa55w0rd')\n    */\n\n  }, {\n    key: \"setPassword\",\n    value: function setPassword(username, password) {\n      return this._pool.json(this._getQueryOpts({\n        q: \"set password for \".concat(grammar.escape.quoted(username), \" = \") + grammar.escape.stringLit(password)\n      }, 'POST')).then(results_1.assertNoErrors).then(function () {\n        return undefined;\n      });\n    }\n    /**\n    * Grants a privilege to a specified user.\n    * @param username\n    * @param privilege Should be one of 'READ' or 'WRITE'\n    * @param [database] If not provided, uses the default database.\n    * @return\n    * @example\n    * influx.grantPrivilege('connor', 'READ', 'my_db') // grants read access on my_db to connor\n    */\n\n  }, {\n    key: \"grantPrivilege\",\n    value: function grantPrivilege(username, privilege) {\n      var database = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this._defaultDB();\n      return this._pool.json(this._getQueryOpts({\n        q: \"grant \".concat(privilege, \" on \").concat(grammar.escape.quoted(database), \" \") + \"to \".concat(grammar.escape.quoted(username))\n      }, 'POST')).then(results_1.assertNoErrors).then(function () {\n        return undefined;\n      });\n    }\n    /**\n    * Removes a privilege from a specified user.\n    * @param username\n    * @param privilege Should be one of 'READ' or 'WRITE'\n    * @param [database] If not provided, uses the default database.\n    * @return\n    * @example\n    * influx.revokePrivilege('connor', 'READ', 'my_db') // removes read access on my_db from connor\n    */\n\n  }, {\n    key: \"revokePrivilege\",\n    value: function revokePrivilege(username, privilege) {\n      var database = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this._defaultDB();\n      return this._pool.json(this._getQueryOpts({\n        q: \"revoke \".concat(privilege, \" on \").concat(grammar.escape.quoted(database), \" from \") + grammar.escape.quoted(username)\n      }, 'POST')).then(results_1.assertNoErrors).then(function () {\n        return undefined;\n      });\n    }\n    /**\n    * Grants admin privileges to a specified user.\n    * @param username\n    * @return\n    * @example\n    * influx.grantAdminPrivilege('connor')\n    */\n\n  }, {\n    key: \"grantAdminPrivilege\",\n    value: function grantAdminPrivilege(username) {\n      return this._pool.json(this._getQueryOpts({\n        q: \"grant all to \".concat(grammar.escape.quoted(username))\n      }, 'POST')).then(results_1.assertNoErrors).then(function () {\n        return undefined;\n      });\n    }\n    /**\n    * Removes a admin privilege from a specified user.\n    * @param username\n    * @return\n    * @example\n    * influx.revokeAdminPrivilege('connor')\n    */\n\n  }, {\n    key: \"revokeAdminPrivilege\",\n    value: function revokeAdminPrivilege(username) {\n      return this._pool.json(this._getQueryOpts({\n        q: \"revoke all from \".concat(grammar.escape.quoted(username))\n      }, 'POST')).then(results_1.assertNoErrors).then(function () {\n        return undefined;\n      });\n    }\n    /**\n    * Removes a user from the database.\n    * @param username\n    * @return\n    * @example\n    * influx.dropUser('connor')\n    */\n\n  }, {\n    key: \"dropUser\",\n    value: function dropUser(username) {\n      return this._pool.json(this._getQueryOpts({\n        q: \"drop user \".concat(grammar.escape.quoted(username))\n      }, 'POST')).then(results_1.assertNoErrors).then(function () {\n        return undefined;\n      });\n    }\n    /**\n    * Creates a continuous query in a database\n    * @param name The query name, for later reference\n    * @param query The body of the query to run\n    * @param [database] If not provided, uses the default database.\n    * @param [resample] If provided, adds resample policy\n    * @return\n    * @example\n    * influx.createContinuousQuery('downsample_cpu_1h', `\n    *   SELECT MEAN(cpu) INTO \"7d\".\"perf\"\n    *   FROM \"1d\".\"perf\" GROUP BY time(1m)\n    * `, undefined, 'RESAMPLE FOR 7m')\n    */\n\n  }, {\n    key: \"createContinuousQuery\",\n    value: function createContinuousQuery(name, query) {\n      var database = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this._defaultDB();\n      var resample = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';\n      return this._pool.json(this._getQueryOpts({\n        q: \"create continuous query \".concat(grammar.escape.quoted(name)) + \" on \".concat(grammar.escape.quoted(database), \" \").concat(resample, \" begin \").concat(query, \" end\")\n      }, 'POST')).then(results_1.assertNoErrors).then(function () {\n        return undefined;\n      });\n    }\n    /**\n    * Returns a list of continous queries in the database.\n    * @param [database] If not provided, uses the default database.\n    * @return\n    * @example\n    * influx.showContinousQueries()\n    */\n\n  }, {\n    key: \"showContinousQueries\",\n    value: function showContinousQueries() {\n      var database = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._defaultDB();\n      return this._pool.json(this._getQueryOpts({\n        db: database,\n        q: 'show continuous queries'\n      })).then(function (result) {\n        return results_1.parseSingle(result);\n      });\n    }\n    /**\n    * Creates a continuous query in a database\n    * @param name The query name\n    * @param [database] If not provided, uses the default database.\n    * @return\n    * @example\n    * influx.dropContinuousQuery('downsample_cpu_1h')\n    */\n\n  }, {\n    key: \"dropContinuousQuery\",\n    value: function dropContinuousQuery(name) {\n      var database = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._defaultDB();\n      return this._pool.json(this._getQueryOpts({\n        q: \"drop continuous query \".concat(grammar.escape.quoted(name)) + \" on \".concat(grammar.escape.quoted(database))\n      }, 'POST')).then(results_1.assertNoErrors).then(function () {\n        return undefined;\n      });\n    }\n    /**\n    * Creates a new retention policy on a database. You can read more about\n    * [Downsampling and Retention](https://docs.influxdata.com/influxdb/v1.0/\n    * guides/downsampling_and_retention/) on the InfluxDB website.\n    *\n    * @param name The retention policy name\n    * @param options\n    * @param [options.database] Database to create the policy on,\n    *     uses the default database if not provided.\n    * @param options.duration How long data in the retention policy\n    *     should be stored for, should be in a format like `7d`. See details\n    *     [here](https://docs.influxdata.com/influxdb/v1.0/query_language/spec/#durations)\n    * @param options.replication How many servers data in the series\n    *     should be replicated to.\n    * @param [options.isDefault] Whether the retention policy should\n    *     be the default policy on the database.\n    * @return\n    * @example\n    * influx.createRetentionPolicy('7d', {\n    *  duration: '7d',\n    *  replication: 1\n    * })\n    */\n\n  }, {\n    key: \"createRetentionPolicy\",\n    value: function createRetentionPolicy(name, options) {\n      var q = \"create retention policy \".concat(grammar.escape.quoted(name), \" on \") + grammar.escape.quoted(options.database || this._defaultDB()) + \" duration \".concat(options.duration, \" replication \").concat(options.replication) + (options.isDefault ? ' default' : '');\n      return this._pool.json(this._getQueryOpts({\n        q: q\n      }, 'POST')).then(results_1.assertNoErrors).then(function () {\n        return undefined;\n      });\n    }\n    /**\n    * Alters an existing retention policy on a database.\n    *\n    * @param name The retention policy name\n    * @param options\n    * @param [options.database] Database to create the policy on,\n    *     uses the default database if not provided.\n    * @param options.duration How long data in the retention policy\n    *     should be stored for, should be in a format like `7d`. See details\n    *     [here](https://docs.influxdata.com/influxdb/v1.0/query_language/spec/#durations)\n    * @param options.replication How many servers data in the series\n    *     should be replicated to.\n    * @param [options.default] Whether the retention policy should\n    *     be the default policy on the database.\n    * @return\n    * @example\n    * influx.alterRetentionPolicy('7d', {\n    *  duration: '7d',\n    *  replication: 1,\n    *  default: true\n    * })\n    */\n\n  }, {\n    key: \"alterRetentionPolicy\",\n    value: function alterRetentionPolicy(name, options) {\n      var q = \"alter retention policy \".concat(grammar.escape.quoted(name), \" on \") + grammar.escape.quoted(options.database || this._defaultDB()) + \" duration \".concat(options.duration, \" replication \").concat(options.replication) + (options.isDefault ? ' default' : '');\n      return this._pool.json(this._getQueryOpts({\n        q: q\n      }, 'POST')).then(results_1.assertNoErrors).then(function () {\n        return undefined;\n      });\n    }\n    /**\n    * Deletes a retention policy and associated data. Note that the data will\n    * not be immediately destroyed, and will hang around until Influx's\n    * bi-hourly cron.\n    *\n    * @param name The retention policy name\n    * @param [database] Database name that the policy lives in,\n    *     uses the default database if not provided.\n    * @return\n    * @example\n    * influx.dropRetentionPolicy('7d')\n    */\n\n  }, {\n    key: \"dropRetentionPolicy\",\n    value: function dropRetentionPolicy(name) {\n      var database = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._defaultDB();\n      return this._pool.json(this._getQueryOpts({\n        q: \"drop retention policy \".concat(grammar.escape.quoted(name), \" \") + \"on \".concat(grammar.escape.quoted(database))\n      }, 'POST')).then(results_1.assertNoErrors).then(function () {\n        return undefined;\n      });\n    }\n    /**\n    * Shows retention policies on the database\n    *\n    * @param [database] The database to list policies on, uses the\n    *     default database if not provided.\n    * @return\n    * @example\n    * influx.showRetentionPolicies().then(policies => {\n    *   expect(policies.slice()).to.deep.equal([\n    *     {\n    *       name: 'autogen',\n    *       duration: '0s',\n    *       shardGroupDuration: '168h0m0s',\n    *       replicaN: 1,\n    *       default: true,\n    *     },\n    *     {\n    *       name: '7d',\n    *       duration: '168h0m0s',\n    *       shardGroupDuration: '24h0m0s',\n    *       replicaN: 1,\n    *       default: false,\n    *     },\n    *   ])\n    * })\n    */\n\n  }, {\n    key: \"showRetentionPolicies\",\n    value: function showRetentionPolicies() {\n      var database = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._defaultDB();\n      return this._pool.json(this._getQueryOpts({\n        q: \"show retention policies on \".concat(grammar.escape.quoted(database))\n      }, 'GET')).then(function (result) {\n        return results_1.parseSingle(result);\n      });\n    }\n    /**\n    * Shows shards on the database\n    *\n    * @param [database] The database to list policies on, uses the\n    *     default database if not provided.\n    * @return\n    * @example\n    * influx.showShards().then(shards => {\n    *   expect(shards.slice()).to.deep.equal([\n    *     {\n    *\t\tid: 1\n    *\t\tdatabase: 'database',\n    *\t\tretention_policy: 'autogen',\n    *\t\tshard_group: 1,\n    *\t\tstart_time: '2019-05-06T00:00:00Z',\n    *\t\tend_time: '2019-05-13T00:00:00Z',\n    *\t\texpiry_time: '2019-05-13T00:00:00Z',\n    *\t\towners: null,\n    *     },\n    *   ])\n    * })\n    */\n\n  }, {\n    key: \"showShards\",\n    value: function showShards() {\n      var database = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._defaultDB();\n      return this._pool.json(this._getQueryOpts({\n        q: 'show shards '\n      }, 'GET')).then(function (result) {\n        return results_1.parseSingle(result).filter(function (i) {\n          return i.database === database;\n        });\n      });\n    }\n    /**\n    * Drops a shard with the provided number.\n    * @param shard_id\n    * @return\n    * @example\n    * influx.dropShard(3)\n    */\n\n  }, {\n    key: \"dropShard\",\n    value: function dropShard(shard_id) {\n      return this._pool.json(this._getQueryOpts({\n        q: \"drop shard \".concat(shard_id)\n      }, 'POST')).then(results_1.assertNoErrors).then(function () {\n        return undefined;\n      });\n    }\n    /**\n    * WritePoints sends a list of points together in a batch to InfluxDB. In\n    * each point you must specify the measurement name to write into as well\n    * as a list of tag and field values. Optionally, you can specify the\n    * time to tag that point at, defaulting to the current time.\n    *\n    * If you defined a schema for the measurement in the options you passed\n    * to `new Influx(options)`, we'll use that to make sure that types get\n    * cast correctly and that there are no extraneous fields or columns.\n    *\n    * For best performance, it's recommended that you batch your data into\n    * sets of a couple thousand records before writing it. In the future we'll\n    * have some utilities within node-influx to make this easier.\n    *\n    * ---\n    *\n    * A note when using manually-specified times and precisions: by default\n    * we write using the `ms` precision since that's what JavaScript gives us.\n    * You can adjust this. However, there is some special behaviour if you\n    * manually specify a timestamp in your points:\n    *  - if you specify the timestamp as a Date object, we'll convert it to\n    *    milliseconds and manipulate it as needed to get the right precision\n    *  - if provide a INanoDate as returned from {@link toNanoTime} or the\n    *    results from an Influx query, we'll be able to pull the precise\n    *    nanosecond timestamp and manipulate it to get the right precision\n    *  - if you provide a string or number as the timestamp, we'll pass it\n    *    straight into Influx.\n    *\n    * Please see the IPoint and IWriteOptions types for a\n    * full list of possible options.\n    *\n    * @param points\n    * @param [options]\n    * @return\n    * @example\n    * // write a point into the default database with\n    * // the default retention policy.\n    * influx.writePoints([\n    *   {\n    *     measurement: 'perf',\n    *     tags: { host: 'box1.example.com' },\n    *     fields: { cpu: getCpuUsage(), mem: getMemUsage() },\n    *   }\n    * ])\n    *\n    * // you can manually specify the database,\n    * // retention policy, and time precision:\n    * influx.writePoints([\n    *   {\n    *     measurement: 'perf',\n    *     tags: { host: 'box1.example.com' },\n    *     fields: { cpu: getCpuUsage(), mem: getMemUsage() },\n    *     timestamp: getLastRecordedTime(),\n    *   }\n    * ], {\n    *   database: 'my_db',\n    *   retentionPolicy: '1d',\n    *   precision: 's'\n    * })\n    */\n\n  }, {\n    key: \"writePoints\",\n    value: function writePoints(points) {\n      var _this2 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var _options$database2 = options.database,\n          database = _options$database2 === void 0 ? this._defaultDB() : _options$database2,\n          _options$precision = options.precision,\n          precision = _options$precision === void 0 ? 'n' : _options$precision,\n          retentionPolicy = options.retentionPolicy;\n      var payload = '';\n      points.forEach(function (point) {\n        var _point$fields = point.fields,\n            fields = _point$fields === void 0 ? {} : _point$fields,\n            _point$tags = point.tags,\n            tags = _point$tags === void 0 ? {} : _point$tags,\n            measurement = point.measurement,\n            timestamp = point.timestamp;\n        var schema = _this2._schema[database] && _this2._schema[database][measurement];\n        var fieldsPairs = schema ? schema.coerceFields(fields) : schema_1.coerceBadly(fields);\n        var tagsNames = schema ? schema.checkTags(tags) : Object.keys(tags);\n        payload += (payload.length > 0 ? '\\n' : '') + measurement;\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = tagsNames[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var tagsName = _step.value;\n            payload += ',' + grammar.escape.tag(tagsName) + '=' + grammar.escape.tag(tags[tagsName]);\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n\n        for (var i = 0; i < fieldsPairs.length; i += 1) {\n          payload += (i === 0 ? ' ' : ',') + grammar.escape.tag(fieldsPairs[i][0]) + '=' + fieldsPairs[i][1];\n        }\n\n        if (timestamp !== undefined) {\n          payload += ' ' + grammar.castTimestamp(timestamp, precision);\n        }\n      });\n      return this._pool.discard({\n        body: payload,\n        method: 'POST',\n        path: '/write',\n        query: {\n          db: database,\n          p: this._options.password,\n          precision: precision,\n          rp: retentionPolicy,\n          u: this._options.username\n        }\n      });\n    }\n    /**\n    * WriteMeasurement functions similarly to {@link InfluxDB#writePoints}, but\n    * it automatically fills in the `measurement` value for all points for you.\n    *\n    * @param measurement\n    * @param points\n    * @param [options]\n    * @return\n    * @example\n    * influx.writeMeasurement('perf', [\n    *   {\n    *     tags: { host: 'box1.example.com' },\n    *     fields: { cpu: getCpuUsage(), mem: getMemUsage() },\n    *   }\n    * ])\n    */\n\n  }, {\n    key: \"writeMeasurement\",\n    value: function writeMeasurement(measurement, points) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      points = points.map(function (p) {\n        return Object.assign({\n          measurement: measurement\n        }, p);\n      });\n      return this.writePoints(points, options);\n    }\n    /**\n    * .query() runs a query (or list of queries), and returns the results in a\n    * friendly format, {@link IResults}. If you run multiple queries, an array of results\n    * will be returned, otherwise a single result (array of objects) will be returned.\n    *\n    * @param query\n    * @param [options]\n    * @return result(s)\n    * @example\n    * influx.query('select * from perf').then(results => {\n    *   console.log(results)\n    * })\n    */\n\n  }, {\n    key: \"query\",\n    value: function query(_query) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (Array.isArray(_query)) {\n        _query = _query.join(';');\n      } // If the consumer asked explicitly for nanosecond precision parsing,\n      // remove that to cause Influx to give us ISO dates that\n      // we can parse correctly.\n\n\n      if (options.precision === 'n') {\n        options = Object.assign({}, options); // Avoid mutating\n\n        delete options.precision;\n      }\n\n      return this.queryRaw(_query, options).then(function (res) {\n        return results_1.parse(res, options.precision);\n      });\n    }\n    /**\n    * QueryRaw functions similarly to .query() but it does no fancy\n    * transformations on the returned data; it calls `JSON.parse` and returns\n    * those results verbatim.\n    *\n    * @param query\n    * @param [options]\n    * @return\n    * @example\n    * influx.queryRaw('select * from perf').then(rawData => {\n    *   console.log(rawData)\n    * })\n    */\n\n  }, {\n    key: \"queryRaw\",\n    value: function queryRaw(query) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var _options$database3 = options.database,\n          database = _options$database3 === void 0 ? this._defaultDB() : _options$database3,\n          retentionPolicy = options.retentionPolicy;\n\n      if (query instanceof Array) {\n        query = query.join(';');\n      }\n\n      return this._pool.json(this._getQueryOpts({\n        db: database,\n        epoch: options.precision,\n        q: query,\n        rp: retentionPolicy\n      }));\n    }\n    /**\n    * Pings all available hosts, collecting online status and version info.\n    * @param timeout Given in milliseconds\n    * @return\n    * @example\n    * influx.ping(5000).then(hosts => {\n    *   hosts.forEach(host => {\n    *     if (host.online) {\n    *       console.log(`${host.url.host} responded in ${host.rtt}ms running ${host.version})`)\n    *     } else {\n    *       console.log(`${host.url.host} is offline :(`)\n    *     }\n    *   })\n    * })\n    */\n\n  }, {\n    key: \"ping\",\n    value: function ping(timeout) {\n      return this._pool.ping(timeout);\n    }\n    /**\n    * Returns the default database that queries operates on. It throws if called\n    * when a default database isn't set.\n    * @private\n    */\n\n  }, {\n    key: \"_defaultDB\",\n    value: function _defaultDB() {\n      if (!this._options.database) {\n        throw new Error('Attempted to run an influx query without a default' + ' database specified or an explicit database provided.');\n      }\n\n      return this._options.database;\n    }\n    /**\n    * Creates options to be passed into the pool to query databases.\n    * @private\n    */\n\n  }, {\n    key: \"_getQueryOpts\",\n    value: function _getQueryOpts(params) {\n      var method = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'GET';\n      return {\n        method: method,\n        path: '/query',\n        query: Object.assign({\n          p: this._options.password,\n          u: this._options.username\n        }, params)\n      };\n    }\n    /**\n    * Creates specified measurement schema\n    *\n    * @private\n    * @param {ISchemaOptions} schema\n    * @memberof InfluxDB\n    */\n\n  }, {\n    key: \"_createSchema\",\n    value: function _createSchema(schema) {\n      schema.database = schema.database || this._options.database;\n\n      if (!schema.database) {\n        throw new Error(\"Schema \".concat(schema.measurement, \" doesn't have a database specified,\") + 'and no default database is provided!');\n      }\n\n      if (!this._schema[schema.database]) {\n        this._schema[schema.database] = Object.create(null);\n      }\n\n      this._schema[schema.database][schema.measurement] = new schema_1.Schema(schema);\n    }\n  }]);\n\n  return InfluxDB;\n}();\n\nexports.InfluxDB = InfluxDB;","map":{"version":3,"sources":["/Users/kyungjoon/react_pjt/edge-cloud-ui_current-working/node_modules/influx/lib/src/index.js"],"names":["__export","m","p","exports","hasOwnProperty","Object","defineProperty","value","url","require","b","grammar","pool_1","results_1","schema_1","defaultHost","freeze","host","port","path","protocol","defaultOptions","database","hosts","password","schema","username","grammar_1","FieldType","Precision","Raw","escape","toNanoDate","results_2","ResultError","parseOptionsUrl","addr","parsed","parse","options","hostname","Number","slice","auth","split","pathname","length","defaults","target","srcs","forEach","src","keys","key","undefined","InfluxDB","_schema","create","pool","resolved","map","_pool","Pool","_options","addHost","_createSchema","databaseName","json","_getQueryOpts","q","quoted","then","assertNoErrors","res","parseSingle","r","name","_defaultDB","db","measurement","query","parseMeasurement","parseWhere","result","admin","stringLit","privilege","resample","duration","replication","isDefault","filter","i","shard_id","points","precision","retentionPolicy","payload","point","fields","tags","timestamp","fieldsPairs","coerceFields","coerceBadly","tagsNames","checkTags","tagsName","tag","castTimestamp","discard","body","method","rp","u","assign","writePoints","Array","isArray","join","queryRaw","epoch","timeout","ping","Error","params","Schema"],"mappings":"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","sourcesContent":["\"use strict\";\n/* eslint-disable @typescript-eslint/unified-signatures */\n/* eslint-disable no-dupe-class-members */\n/* eslint-disable no-prototype-builtins */\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst url = require(\"url\");\nconst b = require(\"./builder\");\nconst grammar = require(\"./grammar\");\nconst pool_1 = require(\"./pool\");\nconst results_1 = require(\"./results\");\nconst schema_1 = require(\"./schema\");\nconst defaultHost = Object.freeze({\n    host: '127.0.0.1',\n    port: 8086,\n    path: '',\n    protocol: 'http'\n});\nconst defaultOptions = Object.freeze({\n    database: null,\n    hosts: [],\n    password: 'root',\n    schema: [],\n    username: 'root'\n});\n__export(require(\"./builder\"));\nvar grammar_1 = require(\"./grammar\");\nexports.FieldType = grammar_1.FieldType;\nexports.Precision = grammar_1.Precision;\nexports.Raw = grammar_1.Raw;\nexports.escape = grammar_1.escape;\nexports.toNanoDate = grammar_1.toNanoDate;\nvar results_2 = require(\"./results\");\nexports.ResultError = results_2.ResultError;\n/**\n * Parses the URL out into into a IClusterConfig object\n */\nfunction parseOptionsUrl(addr) {\n    const parsed = url.parse(addr);\n    const options = {\n        host: parsed.hostname,\n        port: Number(parsed.port),\n        protocol: parsed.protocol.slice(0, -1)\n    };\n    if (parsed.auth) {\n        [options.username, options.password] = parsed.auth.split(':');\n    }\n    if (parsed.pathname.length > 1) {\n        options.database = parsed.pathname.slice(1);\n    }\n    return options;\n}\n/**\n * Works similarly to Object.assign, but only overwrites\n * properties that resolve to undefined.\n */\nfunction defaults(target, ...srcs) {\n    srcs.forEach(src => {\n        Object.keys(src).forEach((key) => {\n            if (target[key] === undefined) {\n                target[key] = src[key];\n            }\n        });\n    });\n    return target;\n}\n/**\n * InfluxDB is the public interface to run queries against the your database.\n * This is a 'driver-level' module, not a a full-fleged ORM or ODM; you run\n * queries directly by calling methods on this class.\n *\n * Please check out some of [the tutorials](https://node-influx.github.io/manual/tutorial.html)\n * if you want help getting started!\n *\n * @example\n * const Influx = require('influx');\n * const influx = new Influx.InfluxDB({\n *  host: 'localhost',\n *  database: 'express_response_db',\n *  schema: [\n *    {\n *      measurement: 'response_times',\n *      fields: {\n *        path: Influx.FieldType.STRING,\n *        duration: Influx.FieldType.INTEGER\n *      },\n *      tags: [\n *        'host'\n *      ]\n *    }\n *  ]\n * })\n *\n * @example\n * // Connect over HTTPS\n * const Influx = require('influx');\n * const influx = new Influx.InfluxDB({\n *  host: 'myinfluxdbhost',\n *  port: 443,\n *  protocol: 'https'\n *  database: 'express_response_db',\n *  schema: [\n *    {\n *      measurement: 'response_times',\n *      fields: {\n *        path: Influx.FieldType.STRING,\n *        duration: Influx.FieldType.INTEGER\n *      },\n *      tags: [\n *        'host'\n *      ]\n *    }\n *  ]\n * })\n *\n * influx.writePoints([\n *   {\n *     measurement: 'response_times',\n *     tags: { host: os.hostname() },\n *     fields: { duration, path: req.path },\n *   }\n * ]).then(() => {\n *   return influx.query(`\n *     select * from response_times\n *     where host = ${Influx.escape.stringLit(os.hostname())}\n *     order by time desc\n *     limit 10\n *   `)\n * }).then(rows => {\n *   rows.forEach(row => console.log(`A request to ${row.path} took ${row.duration}ms`))\n * })\n */\nclass InfluxDB {\n    /**\n   * Connect to a single InfluxDB instance by specifying\n   * a set of connection options.\n   * @param [options='http://root:root@127.0.0.1:8086']\n   *\n   * @example\n   * const Influx = require('influx')\n   *\n   * // Connect to a single host with a DSN:\n   * const influx = new Influx.InfluxDB('http://user:password@host:8086/database')\n   *\n   * @example\n   * const Influx = require('influx')\n   *\n   * // Connect to a single host with a full set of config details and\n   * // a custom schema\n   * const client = new Influx.InfluxDB({\n   *   database: 'my_db',\n   *   host: 'localhost',\n   *   port: 8086,\n   *   username: 'connor',\n   *   password: 'pa$$w0rd',\n   *   schema: [\n   *     {\n   *       measurement: 'perf',\n   *       fields: {\n   *         memory_usage: Influx.FieldType.INTEGER,\n   *         cpu_usage: Influx.FieldType.FLOAT,\n   *         is_online: Influx.FieldType.BOOLEAN\n   *       }\n   *       tags: [\n   *         'hostname'\n   *       ]\n   *     }\n   *   ]\n   * })\n   *\n   * @example\n   * const Influx = require('influx')\n   *\n   * // Use a pool of several host connections and balance queries across them:\n   * const client = new Influx.InfluxDB({\n   *   database: 'my_db',\n   *   username: 'connor',\n   *   password: 'pa$$w0rd',\n   *   hosts: [\n   *     { host: 'db1.example.com' },\n   *     { host: 'db2.example.com' },\n   *   ],\n   *   schema: [\n   *     {\n   *       measurement: 'perf',\n   *       fields: {\n   *         memory_usage: Influx.FieldType.INTEGER,\n   *         cpu_usage: Influx.FieldType.FLOAT,\n   *         is_online: Influx.FieldType.BOOLEAN\n   *       }\n   *       tags: [\n   *         'hostname'\n   *       ]\n   *     }\n   *   ]\n   * })\n   *\n   */\n    constructor(options) {\n        /**\n       * Map of Schema instances defining measurements in Influx.\n       * @private\n       */\n        this._schema = Object.create(null);\n        // Figure out how to parse whatever we were passed in into a IClusterConfig.\n        if (typeof options === 'string') {\n            // Plain URI => ISingleHostConfig\n            options = parseOptionsUrl(options);\n        }\n        else if (!options) {\n            options = defaultHost;\n        }\n        if (!options.hasOwnProperty('hosts')) {\n            // ISingleHostConfig => IClusterConfig\n            options = {\n                database: options.database,\n                hosts: [options],\n                password: options.password,\n                pool: options.pool,\n                schema: options.schema,\n                username: options.username\n            };\n        }\n        const resolved = options;\n        resolved.hosts = resolved.hosts.map(host => {\n            return defaults({\n                host: host.host,\n                port: host.port,\n                path: host.path,\n                protocol: host.protocol,\n                options: host.options\n            }, defaultHost);\n        });\n        this._pool = new pool_1.Pool(resolved.pool);\n        this._options = defaults(resolved, defaultOptions);\n        resolved.hosts.forEach(host => {\n            this._pool.addHost(`${host.protocol}://${host.host}:${host.port}${host.path}`, host.options);\n        });\n        this._options.schema.forEach(schema => this._createSchema(schema));\n    }\n    /**\n   * Adds specified schema for better fields coercing.\n   *\n   * @param {ISchemaOptions} schema\n   * @memberof InfluxDB\n   */\n    addSchema(schema) {\n        this._createSchema(schema);\n    }\n    /**\n   * Creates a new database with the provided name.\n   * @param databaseName\n   * @return\n   * @example\n   * influx.createDatabase('mydb')\n   */\n    createDatabase(databaseName) {\n        return this._pool\n            .json(this._getQueryOpts({\n            q: `create database ${grammar.escape.quoted(databaseName)}`\n        }, 'POST'))\n            .then(results_1.assertNoErrors)\n            .then(() => undefined);\n    }\n    /**\n   * Deletes a database with the provided name.\n   * @param databaseName\n   * @return\n   * @example\n   * influx.dropDatabase('mydb')\n   */\n    dropDatabase(databaseName) {\n        return this._pool\n            .json(this._getQueryOpts({\n            q: `drop database ${grammar.escape.quoted(databaseName)}`\n        }, 'POST'))\n            .then(results_1.assertNoErrors)\n            .then(() => undefined);\n    }\n    /**\n   * Returns array of database names. Requires cluster admin privileges.\n   * @returns a list of database names\n   * @example\n   * influx.getDatabaseNames().then(names =>\n   *   console.log('My database names are: ' + names.join(', ')));\n   */\n    getDatabaseNames() {\n        return this._pool\n            .json(this._getQueryOpts({ q: 'show databases' }))\n            .then(res => results_1.parseSingle(res).map(r => r.name));\n    }\n    /**\n   * Returns array of measurements.\n   * @returns a list of measurement names\n   * @param [database] the database the measurement lives in, optional\n   *     if a default database is provided.\n   * @example\n   * influx.getMeasurements().then(names =>\n   *   console.log('My measurement names are: ' + names.join(', ')));\n   */\n    getMeasurements(database = this._defaultDB()) {\n        return this._pool\n            .json(this._getQueryOpts({\n            db: database,\n            q: 'show measurements'\n        }))\n            .then(res => results_1.parseSingle(res).map(r => r.name));\n    }\n    /**\n   * Returns a list of all series within the target measurement, or from the\n   * entire database if a measurement isn't provided.\n   * @param [options]\n   * @param [options.measurement] if provided, we'll only get series\n   *     from within that measurement.\n   * @param [options.database] the database the series lives in,\n   *     optional if a default database is provided.\n   * @returns a list of series names\n   * @example\n   * influx.getSeries().then(names => {\n   *   console.log('My series names in my_measurement are: ' + names.join(', '))\n   * })\n   *\n   * influx.getSeries({\n   *   measurement: 'my_measurement',\n   *   database: 'my_db'\n   * }).then(names => {\n   *   console.log('My series names in my_measurement are: ' + names.join(', '))\n   * })\n   */\n    getSeries(options = {}) {\n        const { database = this._defaultDB(), measurement } = options;\n        let query = 'show series';\n        if (measurement) {\n            query += ` from ${grammar.escape.quoted(measurement)}`;\n        }\n        return this._pool\n            .json(this._getQueryOpts({\n            db: database,\n            q: query\n        }))\n            .then(res => results_1.parseSingle(res).map(r => r.key));\n    }\n    /**\n   * Removes a measurement from the database.\n   * @param measurement\n   * @param [database] the database the measurement lives in, optional\n   *     if a default database is provided.\n   * @return\n   * @example\n   * influx.dropMeasurement('my_measurement')\n   */\n    dropMeasurement(measurement, database = this._defaultDB()) {\n        return this._pool\n            .json(this._getQueryOpts({\n            db: database,\n            q: `drop measurement ${grammar.escape.quoted(measurement)}`\n        }, 'POST'))\n            .then(results_1.assertNoErrors)\n            .then(() => undefined);\n    }\n    /**\n   * Removes a one or more series from InfluxDB.\n   *\n   * @returns\n   * @example\n   * // The following pairs of queries are equivalent: you can chose either to\n   * // use our builder or pass in string directly. The builder takes care\n   * // of escaping and most syntax handling for you.\n   *\n   * influx.dropSeries({ where: e => e.tag('cpu').equals.value('cpu8') })\n   * influx.dropSeries({ where: '\"cpu\" = \\'cpu8\\'' })\n   * // DROP SERIES WHERE \"cpu\" = 'cpu8'\n   *\n   * influx.dropSeries({ measurement: m => m.name('cpu').policy('autogen') })\n   * influx.dropSeries({ measurement: '\"cpu\".\"autogen\"' })\n   * // DROP SERIES FROM \"autogen\".\"cpu\"\n   *\n   * influx.dropSeries({\n   *   measurement: m => m.name('cpu').policy('autogen'),\n   *   where: e => e.tag('cpu').equals.value('cpu8'),\n   *   database: 'my_db'\n   * })\n   * // DROP SERIES FROM \"autogen\".\"cpu\" WHERE \"cpu\" = 'cpu8'\n   */\n    dropSeries(options) {\n        const db = 'database' in options ? options.database : this._defaultDB();\n        let q = 'drop series';\n        if ('measurement' in options) {\n            q += ' from ' + b.parseMeasurement(options);\n        }\n        if ('where' in options) {\n            q += ' where ' + b.parseWhere(options);\n        }\n        return this._pool\n            .json(this._getQueryOpts({ db, q }, 'POST'))\n            .then(results_1.assertNoErrors)\n            .then(() => undefined);\n    }\n    /**\n   * Returns a list of users on the Influx database.\n   * @return\n   * @example\n   * influx.getUsers().then(users => {\n   *   users.forEach(user => {\n   *     if (user.admin) {\n   *       console.log(user.user, 'is an admin!')\n   *     } else {\n   *       console.log(user.user, 'is not an admin!')\n   *     }\n   *   })\n   * })\n   */\n    getUsers() {\n        return this._pool\n            .json(this._getQueryOpts({ q: 'show users' }))\n            .then(result => results_1.parseSingle(result));\n    }\n    /**\n   * Creates a new InfluxDB user.\n   * @param username\n   * @param password\n   * @param [admin=false] If true, the user will be given all\n   *     privileges on all databases.\n   * @return\n   * @example\n   * influx.createUser('connor', 'pa55w0rd', true) // make 'connor' an admin\n   *\n   * // make non-admins:\n   * influx.createUser('not_admin', 'pa55w0rd')\n   */\n    createUser(username, password, admin = false) {\n        return this._pool\n            .json(this._getQueryOpts({\n            q: `create user ${grammar.escape.quoted(username)} with password ` +\n                grammar.escape.stringLit(password) +\n                (admin ? ' with all privileges' : '')\n        }, 'POST'))\n            .then(results_1.assertNoErrors)\n            .then(() => undefined);\n    }\n    /**\n   * Sets a password for an Influx user.\n   * @param username\n   * @param password\n   * @return\n   * @example\n   * influx.setPassword('connor', 'pa55w0rd')\n   */\n    setPassword(username, password) {\n        return this._pool\n            .json(this._getQueryOpts({\n            q: `set password for ${grammar.escape.quoted(username)} = ` +\n                grammar.escape.stringLit(password)\n        }, 'POST'))\n            .then(results_1.assertNoErrors)\n            .then(() => undefined);\n    }\n    /**\n   * Grants a privilege to a specified user.\n   * @param username\n   * @param privilege Should be one of 'READ' or 'WRITE'\n   * @param [database] If not provided, uses the default database.\n   * @return\n   * @example\n   * influx.grantPrivilege('connor', 'READ', 'my_db') // grants read access on my_db to connor\n   */\n    grantPrivilege(username, privilege, database = this._defaultDB()) {\n        return this._pool\n            .json(this._getQueryOpts({\n            q: `grant ${privilege} on ${grammar.escape.quoted(database)} ` +\n                `to ${grammar.escape.quoted(username)}`\n        }, 'POST'))\n            .then(results_1.assertNoErrors)\n            .then(() => undefined);\n    }\n    /**\n   * Removes a privilege from a specified user.\n   * @param username\n   * @param privilege Should be one of 'READ' or 'WRITE'\n   * @param [database] If not provided, uses the default database.\n   * @return\n   * @example\n   * influx.revokePrivilege('connor', 'READ', 'my_db') // removes read access on my_db from connor\n   */\n    revokePrivilege(username, privilege, database = this._defaultDB()) {\n        return this._pool\n            .json(this._getQueryOpts({\n            q: `revoke ${privilege} on ${grammar.escape.quoted(database)} from ` +\n                grammar.escape.quoted(username)\n        }, 'POST'))\n            .then(results_1.assertNoErrors)\n            .then(() => undefined);\n    }\n    /**\n   * Grants admin privileges to a specified user.\n   * @param username\n   * @return\n   * @example\n   * influx.grantAdminPrivilege('connor')\n   */\n    grantAdminPrivilege(username) {\n        return this._pool\n            .json(this._getQueryOpts({\n            q: `grant all to ${grammar.escape.quoted(username)}`\n        }, 'POST'))\n            .then(results_1.assertNoErrors)\n            .then(() => undefined);\n    }\n    /**\n   * Removes a admin privilege from a specified user.\n   * @param username\n   * @return\n   * @example\n   * influx.revokeAdminPrivilege('connor')\n   */\n    revokeAdminPrivilege(username) {\n        return this._pool\n            .json(this._getQueryOpts({\n            q: `revoke all from ${grammar.escape.quoted(username)}`\n        }, 'POST'))\n            .then(results_1.assertNoErrors)\n            .then(() => undefined);\n    }\n    /**\n   * Removes a user from the database.\n   * @param username\n   * @return\n   * @example\n   * influx.dropUser('connor')\n   */\n    dropUser(username) {\n        return this._pool\n            .json(this._getQueryOpts({\n            q: `drop user ${grammar.escape.quoted(username)}`\n        }, 'POST'))\n            .then(results_1.assertNoErrors)\n            .then(() => undefined);\n    }\n    /**\n   * Creates a continuous query in a database\n   * @param name The query name, for later reference\n   * @param query The body of the query to run\n   * @param [database] If not provided, uses the default database.\n   * @param [resample] If provided, adds resample policy\n   * @return\n   * @example\n   * influx.createContinuousQuery('downsample_cpu_1h', `\n   *   SELECT MEAN(cpu) INTO \"7d\".\"perf\"\n   *   FROM \"1d\".\"perf\" GROUP BY time(1m)\n   * `, undefined, 'RESAMPLE FOR 7m')\n   */\n    createContinuousQuery(name, query, database = this._defaultDB(), resample = '') {\n        return this._pool\n            .json(this._getQueryOpts({\n            q: `create continuous query ${grammar.escape.quoted(name)}` +\n                ` on ${grammar.escape.quoted(database)} ${resample} begin ${query} end`\n        }, 'POST'))\n            .then(results_1.assertNoErrors)\n            .then(() => undefined);\n    }\n    /**\n   * Returns a list of continous queries in the database.\n   * @param [database] If not provided, uses the default database.\n   * @return\n   * @example\n   * influx.showContinousQueries()\n   */\n    showContinousQueries(database = this._defaultDB()) {\n        return this._pool\n            .json(this._getQueryOpts({\n            db: database,\n            q: 'show continuous queries'\n        }))\n            .then(result => results_1.parseSingle(result));\n    }\n    /**\n   * Creates a continuous query in a database\n   * @param name The query name\n   * @param [database] If not provided, uses the default database.\n   * @return\n   * @example\n   * influx.dropContinuousQuery('downsample_cpu_1h')\n   */\n    dropContinuousQuery(name, database = this._defaultDB()) {\n        return this._pool\n            .json(this._getQueryOpts({\n            q: `drop continuous query ${grammar.escape.quoted(name)}` +\n                ` on ${grammar.escape.quoted(database)}`\n        }, 'POST'))\n            .then(results_1.assertNoErrors)\n            .then(() => undefined);\n    }\n    /**\n   * Creates a new retention policy on a database. You can read more about\n   * [Downsampling and Retention](https://docs.influxdata.com/influxdb/v1.0/\n   * guides/downsampling_and_retention/) on the InfluxDB website.\n   *\n   * @param name The retention policy name\n   * @param options\n   * @param [options.database] Database to create the policy on,\n   *     uses the default database if not provided.\n   * @param options.duration How long data in the retention policy\n   *     should be stored for, should be in a format like `7d`. See details\n   *     [here](https://docs.influxdata.com/influxdb/v1.0/query_language/spec/#durations)\n   * @param options.replication How many servers data in the series\n   *     should be replicated to.\n   * @param [options.isDefault] Whether the retention policy should\n   *     be the default policy on the database.\n   * @return\n   * @example\n   * influx.createRetentionPolicy('7d', {\n   *  duration: '7d',\n   *  replication: 1\n   * })\n   */\n    createRetentionPolicy(name, options) {\n        const q = `create retention policy ${grammar.escape.quoted(name)} on ` +\n            grammar.escape.quoted(options.database || this._defaultDB()) +\n            ` duration ${options.duration} replication ${options.replication}` +\n            (options.isDefault ? ' default' : '');\n        return this._pool\n            .json(this._getQueryOpts({ q }, 'POST'))\n            .then(results_1.assertNoErrors)\n            .then(() => undefined);\n    }\n    /**\n   * Alters an existing retention policy on a database.\n   *\n   * @param name The retention policy name\n   * @param options\n   * @param [options.database] Database to create the policy on,\n   *     uses the default database if not provided.\n   * @param options.duration How long data in the retention policy\n   *     should be stored for, should be in a format like `7d`. See details\n   *     [here](https://docs.influxdata.com/influxdb/v1.0/query_language/spec/#durations)\n   * @param options.replication How many servers data in the series\n   *     should be replicated to.\n   * @param [options.default] Whether the retention policy should\n   *     be the default policy on the database.\n   * @return\n   * @example\n   * influx.alterRetentionPolicy('7d', {\n   *  duration: '7d',\n   *  replication: 1,\n   *  default: true\n   * })\n   */\n    alterRetentionPolicy(name, options) {\n        const q = `alter retention policy ${grammar.escape.quoted(name)} on ` +\n            grammar.escape.quoted(options.database || this._defaultDB()) +\n            ` duration ${options.duration} replication ${options.replication}` +\n            (options.isDefault ? ' default' : '');\n        return this._pool\n            .json(this._getQueryOpts({ q }, 'POST'))\n            .then(results_1.assertNoErrors)\n            .then(() => undefined);\n    }\n    /**\n   * Deletes a retention policy and associated data. Note that the data will\n   * not be immediately destroyed, and will hang around until Influx's\n   * bi-hourly cron.\n   *\n   * @param name The retention policy name\n   * @param [database] Database name that the policy lives in,\n   *     uses the default database if not provided.\n   * @return\n   * @example\n   * influx.dropRetentionPolicy('7d')\n   */\n    dropRetentionPolicy(name, database = this._defaultDB()) {\n        return this._pool\n            .json(this._getQueryOpts({\n            q: `drop retention policy ${grammar.escape.quoted(name)} ` +\n                `on ${grammar.escape.quoted(database)}`\n        }, 'POST'))\n            .then(results_1.assertNoErrors)\n            .then(() => undefined);\n    }\n    /**\n   * Shows retention policies on the database\n   *\n   * @param [database] The database to list policies on, uses the\n   *     default database if not provided.\n   * @return\n   * @example\n   * influx.showRetentionPolicies().then(policies => {\n   *   expect(policies.slice()).to.deep.equal([\n   *     {\n   *       name: 'autogen',\n   *       duration: '0s',\n   *       shardGroupDuration: '168h0m0s',\n   *       replicaN: 1,\n   *       default: true,\n   *     },\n   *     {\n   *       name: '7d',\n   *       duration: '168h0m0s',\n   *       shardGroupDuration: '24h0m0s',\n   *       replicaN: 1,\n   *       default: false,\n   *     },\n   *   ])\n   * })\n   */\n    showRetentionPolicies(database = this._defaultDB()) {\n        return this._pool\n            .json(this._getQueryOpts({\n            q: `show retention policies on ${grammar.escape.quoted(database)}`\n        }, 'GET'))\n            .then(result => results_1.parseSingle(result));\n    }\n    /**\n   * Shows shards on the database\n   *\n   * @param [database] The database to list policies on, uses the\n   *     default database if not provided.\n   * @return\n   * @example\n   * influx.showShards().then(shards => {\n    *   expect(shards.slice()).to.deep.equal([\n    *     {\n    *\t\tid: 1\n    *\t\tdatabase: 'database',\n    *\t\tretention_policy: 'autogen',\n    *\t\tshard_group: 1,\n    *\t\tstart_time: '2019-05-06T00:00:00Z',\n    *\t\tend_time: '2019-05-13T00:00:00Z',\n    *\t\texpiry_time: '2019-05-13T00:00:00Z',\n    *\t\towners: null,\n    *     },\n    *   ])\n    * })\n  */\n    showShards(database = this._defaultDB()) {\n        return this._pool\n            .json(this._getQueryOpts({\n            q: 'show shards '\n        }, 'GET'))\n            .then(result => results_1.parseSingle(result).filter(function (i) {\n            return i.database === database;\n        }));\n    }\n    /**\n   * Drops a shard with the provided number.\n   * @param shard_id\n   * @return\n   * @example\n   * influx.dropShard(3)\n   */\n    dropShard(shard_id) {\n        return this._pool\n            .json(this._getQueryOpts({\n            q: `drop shard ${shard_id}`\n        }, 'POST'))\n            .then(results_1.assertNoErrors)\n            .then(() => undefined);\n    }\n    /**\n   * WritePoints sends a list of points together in a batch to InfluxDB. In\n   * each point you must specify the measurement name to write into as well\n   * as a list of tag and field values. Optionally, you can specify the\n   * time to tag that point at, defaulting to the current time.\n   *\n   * If you defined a schema for the measurement in the options you passed\n   * to `new Influx(options)`, we'll use that to make sure that types get\n   * cast correctly and that there are no extraneous fields or columns.\n   *\n   * For best performance, it's recommended that you batch your data into\n   * sets of a couple thousand records before writing it. In the future we'll\n   * have some utilities within node-influx to make this easier.\n   *\n   * ---\n   *\n   * A note when using manually-specified times and precisions: by default\n   * we write using the `ms` precision since that's what JavaScript gives us.\n   * You can adjust this. However, there is some special behaviour if you\n   * manually specify a timestamp in your points:\n   *  - if you specify the timestamp as a Date object, we'll convert it to\n   *    milliseconds and manipulate it as needed to get the right precision\n   *  - if provide a INanoDate as returned from {@link toNanoTime} or the\n   *    results from an Influx query, we'll be able to pull the precise\n   *    nanosecond timestamp and manipulate it to get the right precision\n   *  - if you provide a string or number as the timestamp, we'll pass it\n   *    straight into Influx.\n   *\n   * Please see the IPoint and IWriteOptions types for a\n   * full list of possible options.\n   *\n   * @param points\n   * @param [options]\n   * @return\n   * @example\n   * // write a point into the default database with\n   * // the default retention policy.\n   * influx.writePoints([\n   *   {\n   *     measurement: 'perf',\n   *     tags: { host: 'box1.example.com' },\n   *     fields: { cpu: getCpuUsage(), mem: getMemUsage() },\n   *   }\n   * ])\n   *\n   * // you can manually specify the database,\n   * // retention policy, and time precision:\n   * influx.writePoints([\n   *   {\n   *     measurement: 'perf',\n   *     tags: { host: 'box1.example.com' },\n   *     fields: { cpu: getCpuUsage(), mem: getMemUsage() },\n   *     timestamp: getLastRecordedTime(),\n   *   }\n   * ], {\n   *   database: 'my_db',\n   *   retentionPolicy: '1d',\n   *   precision: 's'\n   * })\n   */\n    writePoints(points, options = {}) {\n        const { database = this._defaultDB(), precision = 'n', retentionPolicy } = options;\n        let payload = '';\n        points.forEach(point => {\n            const { fields = {}, tags = {}, measurement, timestamp } = point;\n            const schema = this._schema[database] && this._schema[database][measurement];\n            const fieldsPairs = schema ? schema.coerceFields(fields) : schema_1.coerceBadly(fields);\n            const tagsNames = schema ? schema.checkTags(tags) : Object.keys(tags);\n            payload += (payload.length > 0 ? '\\n' : '') + measurement;\n            for (let tagsName of tagsNames) {\n                payload += ',' + grammar.escape.tag(tagsName) + '=' + grammar.escape.tag(tags[tagsName]);\n            }\n            for (let i = 0; i < fieldsPairs.length; i += 1) {\n                payload +=\n                    (i === 0 ? ' ' : ',') + grammar.escape.tag(fieldsPairs[i][0]) + '=' + fieldsPairs[i][1];\n            }\n            if (timestamp !== undefined) {\n                payload += ' ' + grammar.castTimestamp(timestamp, precision);\n            }\n        });\n        return this._pool.discard({\n            body: payload,\n            method: 'POST',\n            path: '/write',\n            query: { db: database,\n                p: this._options.password,\n                precision,\n                rp: retentionPolicy,\n                u: this._options.username }\n        });\n    }\n    /**\n   * WriteMeasurement functions similarly to {@link InfluxDB#writePoints}, but\n   * it automatically fills in the `measurement` value for all points for you.\n   *\n   * @param measurement\n   * @param points\n   * @param [options]\n   * @return\n   * @example\n   * influx.writeMeasurement('perf', [\n   *   {\n   *     tags: { host: 'box1.example.com' },\n   *     fields: { cpu: getCpuUsage(), mem: getMemUsage() },\n   *   }\n   * ])\n   */\n    writeMeasurement(measurement, points, options = {}) {\n        points = points.map(p => (Object.assign({ measurement }, p)));\n        return this.writePoints(points, options);\n    }\n    /**\n   * .query() runs a query (or list of queries), and returns the results in a\n   * friendly format, {@link IResults}. If you run multiple queries, an array of results\n   * will be returned, otherwise a single result (array of objects) will be returned.\n   *\n   * @param query\n   * @param [options]\n   * @return result(s)\n   * @example\n   * influx.query('select * from perf').then(results => {\n   *   console.log(results)\n   * })\n   */\n    query(query, options = {}) {\n        if (Array.isArray(query)) {\n            query = query.join(';');\n        }\n        // If the consumer asked explicitly for nanosecond precision parsing,\n        // remove that to cause Influx to give us ISO dates that\n        // we can parse correctly.\n        if (options.precision === 'n') {\n            options = Object.assign({}, options); // Avoid mutating\n            delete options.precision;\n        }\n        return this.queryRaw(query, options).then(res => results_1.parse(res, options.precision));\n    }\n    /**\n   * QueryRaw functions similarly to .query() but it does no fancy\n   * transformations on the returned data; it calls `JSON.parse` and returns\n   * those results verbatim.\n   *\n   * @param query\n   * @param [options]\n   * @return\n   * @example\n   * influx.queryRaw('select * from perf').then(rawData => {\n   *   console.log(rawData)\n   * })\n   */\n    queryRaw(query, options = {}) {\n        const { database = this._defaultDB(), retentionPolicy } = options;\n        if (query instanceof Array) {\n            query = query.join(';');\n        }\n        return this._pool.json(this._getQueryOpts({\n            db: database,\n            epoch: options.precision,\n            q: query,\n            rp: retentionPolicy\n        }));\n    }\n    /**\n   * Pings all available hosts, collecting online status and version info.\n   * @param timeout Given in milliseconds\n   * @return\n   * @example\n   * influx.ping(5000).then(hosts => {\n   *   hosts.forEach(host => {\n   *     if (host.online) {\n   *       console.log(`${host.url.host} responded in ${host.rtt}ms running ${host.version})`)\n   *     } else {\n   *       console.log(`${host.url.host} is offline :(`)\n   *     }\n   *   })\n   * })\n   */\n    ping(timeout) {\n        return this._pool.ping(timeout);\n    }\n    /**\n   * Returns the default database that queries operates on. It throws if called\n   * when a default database isn't set.\n   * @private\n   */\n    _defaultDB() {\n        if (!this._options.database) {\n            throw new Error('Attempted to run an influx query without a default' +\n                ' database specified or an explicit database provided.');\n        }\n        return this._options.database;\n    }\n    /**\n   * Creates options to be passed into the pool to query databases.\n   * @private\n   */\n    _getQueryOpts(params, method = 'GET') {\n        return {\n            method,\n            path: '/query',\n            query: Object.assign({ p: this._options.password, u: this._options.username }, params)\n        };\n    }\n    /**\n   * Creates specified measurement schema\n   *\n   * @private\n   * @param {ISchemaOptions} schema\n   * @memberof InfluxDB\n   */\n    _createSchema(schema) {\n        schema.database = schema.database || this._options.database;\n        if (!schema.database) {\n            throw new Error(`Schema ${schema.measurement} doesn't have a database specified,` +\n                'and no default database is provided!');\n        }\n        if (!this._schema[schema.database]) {\n            this._schema[schema.database] = Object.create(null);\n        }\n        this._schema[schema.database][schema.measurement] = new schema_1.Schema(schema);\n    }\n}\nexports.InfluxDB = InfluxDB;\n"]},"metadata":{},"sourceType":"script"}