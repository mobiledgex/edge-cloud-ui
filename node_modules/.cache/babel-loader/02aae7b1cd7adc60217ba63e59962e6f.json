{"ast":null,"code":"\"use strict\";\n/* eslint-disable @typescript-eslint/require-array-sort-compare */\n\n/* eslint-disable no-prototype-builtins */\n\nvar _classCallCheck = require(\"/Users/kyungjoon/react_pjt/edge-cloud-ui_current-working/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/kyungjoon/react_pjt/edge-cloud-ui_current-working/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar grammar_1 = require(\"./grammar\");\n/**\n * The Schema provides information and utilities for an InfluxDB measurement.\n * @private\n */\n\n\nvar Schema =\n/*#__PURE__*/\nfunction () {\n  function Schema(options) {\n    var _this = this;\n\n    _classCallCheck(this, Schema);\n\n    this.options = options;\n    this._tagHash = {}; // FieldNames are sorted for performance: when coerceFields is run the\n    // fields will be added to the output in order.\n\n    this._fieldNames = Object.keys(options.fields).sort();\n    options.tags.forEach(function (tag) {\n      _this._tagHash[tag] = true;\n    });\n  }\n  /**\n  * CoerceFields converts a map of field values to a strings which\n  * can be injected into the line protocol without further escaping.\n  * The output is given in [key, value] pairs.\n  */\n\n\n  _createClass(Schema, [{\n    key: \"coerceFields\",\n    value: function coerceFields(fields) {\n      var _this2 = this;\n\n      var consumed = 0;\n      var output = [];\n\n      this._fieldNames.forEach(function (field) {\n        if (!fields.hasOwnProperty(field)) {\n          return;\n        }\n\n        var value = fields[field];\n        var typ = typeof value;\n        consumed += 1;\n\n        if (value === null || value === undefined) {\n          return;\n        }\n\n        var coerced;\n\n        switch (_this2.options.fields[field]) {\n          case grammar_1.FieldType.STRING:\n            coerced = grammar_1.escape.quoted(String(value));\n            break;\n\n          case grammar_1.FieldType.INTEGER:\n            if (typ !== 'number' && !grammar_1.isNumeric(String(value))) {\n              throw new Error(\"Expected numeric value for \".concat(_this2._ref(field), \", but got '\").concat(value, \"'!\"));\n            }\n\n            coerced = String(Math.floor(value)) + 'i';\n            break;\n\n          case grammar_1.FieldType.FLOAT:\n            if (typ !== 'number' && !grammar_1.isNumeric(String(value))) {\n              throw new Error(\"Expected numeric value for \".concat(_this2._ref(field), \", but got '\").concat(value, \"'!\"));\n            }\n\n            coerced = String(value);\n            break;\n\n          case grammar_1.FieldType.BOOLEAN:\n            if (typ !== 'boolean') {\n              throw new Error(\"Expected boolean value for \".concat(_this2._ref(field), \", but got a \").concat(typ, \"!\"));\n            }\n\n            coerced = value ? 'T' : 'F';\n            break;\n\n          default:\n            throw new Error(\"Unknown field type \".concat(_this2.options.fields[field], \" for \").concat(field, \" in \") + \"\".concat(_this2._ref(), \". Please ensure that your configuration is correct.\"));\n        }\n\n        output.push([field, coerced]);\n      });\n\n      var keys = Object.keys(fields);\n\n      if (consumed !== keys.length) {\n        var extraneous = keys.filter(function (f) {\n          return !_this2._fieldNames.includes(f);\n        });\n        throw new Error('Extraneous fields detected for writing InfluxDB point in ' + \"\".concat(this._ref(), \": `\").concat(extraneous.join('`, `'), \"`.\"));\n      }\n\n      return output;\n    }\n    /**\n    * Throws an error if the tags include values other than\n    * what was specified in the schema. It returns a list of tag names.\n    */\n\n  }, {\n    key: \"checkTags\",\n    value: function checkTags(tags) {\n      var _this3 = this;\n\n      var names = Object.keys(tags);\n      var extraneous = names.filter(function (tag) {\n        return !_this3._tagHash[tag];\n      });\n\n      if (extraneous.length > 0) {\n        throw new Error('Extraneous tags detected for writing InfluxDB point in ' + \"\".concat(this._ref(), \": `\").concat(extraneous.join('`, `'), \"`.\"));\n      }\n\n      return names;\n    }\n    /**\n    * Returns the 'db'.'measurement'[.'field'] referencing the current schema.\n    */\n\n  }, {\n    key: \"_ref\",\n    value: function _ref(field) {\n      var out = this.options.database + '.' + this.options.measurement;\n\n      if (field) {\n        out += '.' + field;\n      }\n\n      return out;\n    }\n  }]);\n\n  return Schema;\n}();\n\nexports.Schema = Schema;\n/**\n * Coerces the field map to a set of writable values, a la coerceFields,\n * using native guesses based on the field datatypes.\n * @private\n */\n\nfunction coerceBadly(fields) {\n  return Object.keys(fields).sort().map(function (field) {\n    var value = fields[field];\n\n    if (typeof value === 'string') {\n      return [field, grammar_1.escape.quoted(value)];\n    }\n\n    return [field, String(value)];\n  });\n}\n\nexports.coerceBadly = coerceBadly;","map":{"version":3,"sources":["/Users/kyungjoon/react_pjt/edge-cloud-ui_current-working/node_modules/influx/lib/src/schema.js"],"names":["Object","defineProperty","exports","value","grammar_1","require","Schema","options","_tagHash","_fieldNames","keys","fields","sort","tags","forEach","tag","consumed","output","field","hasOwnProperty","typ","undefined","coerced","FieldType","STRING","escape","quoted","String","INTEGER","isNumeric","Error","_ref","Math","floor","FLOAT","BOOLEAN","push","length","extraneous","filter","f","includes","join","names","out","database","measurement","coerceBadly","map"],"mappings":"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","sourcesContent":["\"use strict\";\n/* eslint-disable @typescript-eslint/require-array-sort-compare */\n/* eslint-disable no-prototype-builtins */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst grammar_1 = require(\"./grammar\");\n/**\n * The Schema provides information and utilities for an InfluxDB measurement.\n * @private\n */\nclass Schema {\n    constructor(options) {\n        this.options = options;\n        this._tagHash = {};\n        // FieldNames are sorted for performance: when coerceFields is run the\n        // fields will be added to the output in order.\n        this._fieldNames = Object.keys(options.fields).sort();\n        options.tags.forEach(tag => {\n            this._tagHash[tag] = true;\n        });\n    }\n    /**\n   * CoerceFields converts a map of field values to a strings which\n   * can be injected into the line protocol without further escaping.\n   * The output is given in [key, value] pairs.\n   */\n    coerceFields(fields) {\n        let consumed = 0;\n        const output = [];\n        this._fieldNames.forEach(field => {\n            if (!fields.hasOwnProperty(field)) {\n                return;\n            }\n            const value = fields[field];\n            const typ = typeof value;\n            consumed += 1;\n            if (value === null || value === undefined) {\n                return;\n            }\n            let coerced;\n            switch (this.options.fields[field]) {\n                case grammar_1.FieldType.STRING:\n                    coerced = grammar_1.escape.quoted(String(value));\n                    break;\n                case grammar_1.FieldType.INTEGER:\n                    if (typ !== 'number' && !grammar_1.isNumeric(String(value))) {\n                        throw new Error(`Expected numeric value for ${this._ref(field)}, but got '${value}'!`);\n                    }\n                    coerced = String(Math.floor(value)) + 'i';\n                    break;\n                case grammar_1.FieldType.FLOAT:\n                    if (typ !== 'number' && !grammar_1.isNumeric(String(value))) {\n                        throw new Error(`Expected numeric value for ${this._ref(field)}, but got '${value}'!`);\n                    }\n                    coerced = String(value);\n                    break;\n                case grammar_1.FieldType.BOOLEAN:\n                    if (typ !== 'boolean') {\n                        throw new Error(`Expected boolean value for ${this._ref(field)}, but got a ${typ}!`);\n                    }\n                    coerced = value ? 'T' : 'F';\n                    break;\n                default:\n                    throw new Error(`Unknown field type ${this.options.fields[field]} for ${field} in ` +\n                        `${this._ref()}. Please ensure that your configuration is correct.`);\n            }\n            output.push([field, coerced]);\n        });\n        const keys = Object.keys(fields);\n        if (consumed !== keys.length) {\n            const extraneous = keys.filter(f => !this._fieldNames.includes(f));\n            throw new Error('Extraneous fields detected for writing InfluxDB point in ' +\n                `${this._ref()}: \\`${extraneous.join('`, `')}\\`.`);\n        }\n        return output;\n    }\n    /**\n   * Throws an error if the tags include values other than\n   * what was specified in the schema. It returns a list of tag names.\n   */\n    checkTags(tags) {\n        const names = Object.keys(tags);\n        const extraneous = names.filter(tag => !this._tagHash[tag]);\n        if (extraneous.length > 0) {\n            throw new Error('Extraneous tags detected for writing InfluxDB point in ' +\n                `${this._ref()}: \\`${extraneous.join('`, `')}\\`.`);\n        }\n        return names;\n    }\n    /**\n   * Returns the 'db'.'measurement'[.'field'] referencing the current schema.\n   */\n    _ref(field) {\n        let out = this.options.database + '.' + this.options.measurement;\n        if (field) {\n            out += '.' + field;\n        }\n        return out;\n    }\n}\nexports.Schema = Schema;\n/**\n * Coerces the field map to a set of writable values, a la coerceFields,\n * using native guesses based on the field datatypes.\n * @private\n */\nfunction coerceBadly(fields) {\n    return Object.keys(fields)\n        .sort()\n        .map(field => {\n        const value = fields[field];\n        if (typeof value === 'string') {\n            return [field, grammar_1.escape.quoted(value)];\n        }\n        return [field, String(value)];\n    });\n}\nexports.coerceBadly = coerceBadly;\n"]},"metadata":{},"sourceType":"script"}