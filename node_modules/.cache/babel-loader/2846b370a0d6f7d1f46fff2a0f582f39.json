{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/kyungjoon/react_pjt/edge-cloud-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _possibleConstructorReturn = require(\"/Users/kyungjoon/react_pjt/edge-cloud-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/kyungjoon/react_pjt/edge-cloud-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/kyungjoon/react_pjt/edge-cloud-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _wrapNativeSuper = require(\"/Users/kyungjoon/react_pjt/edge-cloud-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/wrapNativeSuper\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar grammar_1 = require(\"./grammar\");\n/**\n * A ResultError is thrown when a query generates errorful results from Influx.\n */\n\n\nvar ResultError =\n/*#__PURE__*/\nfunction (_Error) {\n  _inherits(ResultError, _Error);\n\n  function ResultError(message) {\n    var _this;\n\n    _classCallCheck(this, ResultError);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ResultError).call(this));\n    _this.message = \"Error from InfluxDB: \".concat(message);\n    return _this;\n  }\n\n  return ResultError;\n}(_wrapNativeSuper(Error));\n\nexports.ResultError = ResultError;\n\nfunction groupMethod(matcher) {\n  // We do a tiny bit of 'custom' deep equality checking here, taking\n  // advantage of the fact that the tag keys are consistent across all\n  // series results. This lets us match groupings much more efficiently,\n  // ~6000x faster than the fastest vanilla equality checker (lodash)\n  // when operating on large (~100,000 grouping) sets.\n  var srcKeys = this.groupsTagsKeys;\n  var dstKeys = Object.keys(matcher);\n\n  if (srcKeys.length === 0 || srcKeys.length !== dstKeys.length) {\n    return [];\n  }\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    L: for (var _iterator = this.groupRows[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var row = _step.value;\n      // eslint-disable-line no-labels\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = srcKeys[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var src = _step2.value;\n\n          if (row.tags[src] !== matcher[src]) {\n            continue L; // eslint-disable-line no-labels\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      return row.rows;\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return [];\n}\n\nfunction groupsMethod() {\n  return this.groupRows;\n}\n/**\n * Inner parsing function which unpacks the series into a table and attaches\n * methods to the array. This is quite optimized and a bit of a mess to read,\n * but it's all fairly easy procedural logic.\n *\n * We do this instead of subclassing Array since subclassing has some\n * undesirable side-effects. For example, calling .slice() on the array\n * makes it impossible to preserve groups as would be necessary if it's\n * subclassed.\n */\n\n\nfunction parseInner() {\n  var series = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var precision = arguments.length > 1 ? arguments[1] : undefined;\n  var results = [];\n  results.groupsTagsKeys = series.length && series[0].tags ? Object.keys(series[0].tags) : [];\n  var tags = results.groupsTagsKeys;\n  var nextGroup = [];\n  results.groupRows = new Array(series.length); // Tslint:disable-line\n\n  for (var i = 0; i < series.length; i += 1, results.length) {\n    var _series$i = series[i],\n        _series$i$columns = _series$i.columns,\n        columns = _series$i$columns === void 0 ? [] : _series$i$columns,\n        _series$i$values = _series$i.values,\n        values = _series$i$values === void 0 ? [] : _series$i$values;\n    var _iteratorNormalCompletion3 = true;\n    var _didIteratorError3 = false;\n    var _iteratorError3 = undefined;\n\n    try {\n      for (var _iterator3 = values[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n        var value = _step3.value;\n        var obj = {};\n\n        for (var j = 0; j < columns.length; j += 1) {\n          if (columns[j] === 'time') {\n            obj.time = grammar_1.isoOrTimeToDate(value[j], precision);\n          } else {\n            obj[columns[j]] = value[j];\n          }\n        }\n\n        var _iteratorNormalCompletion4 = true;\n        var _didIteratorError4 = false;\n        var _iteratorError4 = undefined;\n\n        try {\n          for (var _iterator4 = tags[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n            var tag = _step4.value;\n            obj[tag] = series[i].tags[tag];\n          }\n        } catch (err) {\n          _didIteratorError4 = true;\n          _iteratorError4 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n              _iterator4.return();\n            }\n          } finally {\n            if (_didIteratorError4) {\n              throw _iteratorError4;\n            }\n          }\n        }\n\n        results.push(obj);\n        nextGroup.push(obj);\n      }\n    } catch (err) {\n      _didIteratorError3 = true;\n      _iteratorError3 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n          _iterator3.return();\n        }\n      } finally {\n        if (_didIteratorError3) {\n          throw _iteratorError3;\n        }\n      }\n    }\n\n    results.groupRows[i] = {\n      name: series[i].name,\n      rows: nextGroup,\n      tags: series[i].tags || {}\n    };\n    nextGroup = [];\n  }\n\n  results.group = groupMethod;\n  results.groups = groupsMethod;\n  return results;\n}\n/**\n * Checks if there are any errors in the IResponse and, if so, it throws them.\n * @private\n * @throws {ResultError}\n */\n\n\nfunction assertNoErrors(res) {\n  var _iteratorNormalCompletion5 = true;\n  var _didIteratorError5 = false;\n  var _iteratorError5 = undefined;\n\n  try {\n    for (var _iterator5 = res.results[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n      var result = _step5.value;\n      var error = result.error;\n\n      if (error) {\n        throw new ResultError(error);\n      }\n    }\n  } catch (err) {\n    _didIteratorError5 = true;\n    _iteratorError5 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n        _iterator5.return();\n      }\n    } finally {\n      if (_didIteratorError5) {\n        throw _iteratorError5;\n      }\n    }\n  }\n\n  return res;\n}\n\nexports.assertNoErrors = assertNoErrors;\n/**\n * From parses out a response to a result or list of responses.\n * There are three situations we cover here:\n *  1. A single query without groups, like `select * from myseries`\n *  2. A single query with groups, generated with a `group by` statement\n *     which groups by series *tags*, grouping by times is case (1)\n *  3. Multiple queries of types 1 and 2\n * @private\n */\n\nfunction parse(res, precision) {\n  assertNoErrors(res);\n\n  if (res.results.length === 1) {\n    // Normalize case 3\n    return parseInner(res.results[0].series, precision);\n  }\n\n  return res.results.map(function (result) {\n    return parseInner(result.series, precision);\n  });\n}\n\nexports.parse = parse;\n/**\n * ParseSingle asserts that the response contains a single result,\n * and returns that result.\n * @throws {Error} if the number of results is not exactly one\n * @private\n */\n\nfunction parseSingle(res, precision) {\n  assertNoErrors(res);\n\n  if (res.results.length !== 1) {\n    throw new Error('node-influx expected the results length to equal 1, but ' + \"it was \".concat(0, \". Please report this here: https://git.io/influx-err\"));\n  }\n\n  return parseInner(res.results[0].series, precision);\n}\n\nexports.parseSingle = parseSingle;","map":{"version":3,"sources":["/Users/kyungjoon/react_pjt/edge-cloud-ui/node_modules/influx/lib/src/results.js"],"names":["Object","defineProperty","exports","value","grammar_1","require","ResultError","message","Error","groupMethod","matcher","srcKeys","groupsTagsKeys","dstKeys","keys","length","L","groupRows","row","src","tags","rows","groupsMethod","parseInner","series","precision","results","nextGroup","Array","i","columns","values","obj","j","time","isoOrTimeToDate","tag","push","name","group","groups","assertNoErrors","res","result","error","parse","map","parseSingle"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst grammar_1 = require(\"./grammar\");\n/**\n * A ResultError is thrown when a query generates errorful results from Influx.\n */\nclass ResultError extends Error {\n    constructor(message) {\n        super();\n        this.message = `Error from InfluxDB: ${message}`;\n    }\n}\nexports.ResultError = ResultError;\nfunction groupMethod(matcher) {\n    // We do a tiny bit of 'custom' deep equality checking here, taking\n    // advantage of the fact that the tag keys are consistent across all\n    // series results. This lets us match groupings much more efficiently,\n    // ~6000x faster than the fastest vanilla equality checker (lodash)\n    // when operating on large (~100,000 grouping) sets.\n    const srcKeys = this.groupsTagsKeys;\n    const dstKeys = Object.keys(matcher);\n    if (srcKeys.length === 0 || srcKeys.length !== dstKeys.length) {\n        return [];\n    }\n    L: for (let row of this.groupRows) { // eslint-disable-line no-labels\n        for (let src of srcKeys) {\n            if (row.tags[src] !== matcher[src]) {\n                continue L; // eslint-disable-line no-labels\n            }\n        }\n        return row.rows;\n    }\n    return [];\n}\nfunction groupsMethod() {\n    return this.groupRows;\n}\n/**\n * Inner parsing function which unpacks the series into a table and attaches\n * methods to the array. This is quite optimized and a bit of a mess to read,\n * but it's all fairly easy procedural logic.\n *\n * We do this instead of subclassing Array since subclassing has some\n * undesirable side-effects. For example, calling .slice() on the array\n * makes it impossible to preserve groups as would be necessary if it's\n * subclassed.\n */\nfunction parseInner(series = [], precision) {\n    const results = [];\n    results.groupsTagsKeys = series.length && series[0].tags ? Object.keys(series[0].tags) : [];\n    const tags = results.groupsTagsKeys;\n    let nextGroup = [];\n    results.groupRows = new Array(series.length); // Tslint:disable-line\n    for (let i = 0; i < series.length; i += 1, results.length) {\n        const { columns = [], values = [] } = series[i];\n        for (let value of values) {\n            const obj = {};\n            for (let j = 0; j < columns.length; j += 1) {\n                if (columns[j] === 'time') {\n                    obj.time = grammar_1.isoOrTimeToDate(value[j], precision);\n                }\n                else {\n                    obj[columns[j]] = value[j];\n                }\n            }\n            for (let tag of tags) {\n                obj[tag] = series[i].tags[tag];\n            }\n            results.push(obj);\n            nextGroup.push(obj);\n        }\n        results.groupRows[i] = {\n            name: series[i].name,\n            rows: nextGroup,\n            tags: series[i].tags || {}\n        };\n        nextGroup = [];\n    }\n    results.group = groupMethod;\n    results.groups = groupsMethod;\n    return results;\n}\n/**\n * Checks if there are any errors in the IResponse and, if so, it throws them.\n * @private\n * @throws {ResultError}\n */\nfunction assertNoErrors(res) {\n    for (let result of res.results) {\n        const { error } = result;\n        if (error) {\n            throw new ResultError(error);\n        }\n    }\n    return res;\n}\nexports.assertNoErrors = assertNoErrors;\n/**\n * From parses out a response to a result or list of responses.\n * There are three situations we cover here:\n *  1. A single query without groups, like `select * from myseries`\n *  2. A single query with groups, generated with a `group by` statement\n *     which groups by series *tags*, grouping by times is case (1)\n *  3. Multiple queries of types 1 and 2\n * @private\n */\nfunction parse(res, precision) {\n    assertNoErrors(res);\n    if (res.results.length === 1) {\n        // Normalize case 3\n        return parseInner(res.results[0].series, precision);\n    }\n    return res.results.map(result => parseInner(result.series, precision));\n}\nexports.parse = parse;\n/**\n * ParseSingle asserts that the response contains a single result,\n * and returns that result.\n * @throws {Error} if the number of results is not exactly one\n * @private\n */\nfunction parseSingle(res, precision) {\n    assertNoErrors(res);\n    if (res.results.length !== 1) {\n        throw new Error('node-influx expected the results length to equal 1, but ' +\n            `it was ${0}. Please report this here: https://git.io/influx-err`);\n    }\n    return parseInner(res.results[0].series, precision);\n}\nexports.parseSingle = parseSingle;\n"]},"metadata":{},"sourceType":"script"}