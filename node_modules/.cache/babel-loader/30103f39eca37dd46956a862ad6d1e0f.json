{"ast":null,"code":"export default function (o, digits) {\n  if (!(0 <= (digits = +digits) && digits <= 20)) throw new Error(\"invalid digits\");\n\n  function quantizePoint(coordinates) {\n    coordinates[0] = +coordinates[0].toFixed(digits);\n    coordinates[1] = +coordinates[1].toFixed(digits);\n  }\n\n  function quantizePoints(coordinates) {\n    coordinates.forEach(quantizePoint);\n  }\n\n  function quantizePolygon(coordinates) {\n    coordinates.forEach(quantizePoints);\n  }\n\n  function quantizeGeometry(o) {\n    if (o) switch (o.type) {\n      case \"GeometryCollection\":\n        o.geometries.forEach(quantizeGeometry);\n        break;\n\n      case \"Point\":\n        quantizePoint(o.coordinates);\n        break;\n\n      case \"MultiPoint\":\n      case \"LineString\":\n        quantizePoints(o.coordinates);\n        break;\n\n      case \"MultiLineString\":\n      case \"Polygon\":\n        quantizePolygon(o.coordinates);\n        break;\n\n      case \"MultiPolygon\":\n        o.coordinates.forEach(quantizePolygon);\n        break;\n\n      default:\n        return;\n    }\n  }\n\n  function quantizeFeature(o) {\n    quantizeGeometry(o.geometry);\n  }\n\n  if (o) switch (o.type) {\n    case \"Feature\":\n      quantizeFeature(o);\n      break;\n\n    case \"FeatureCollection\":\n      o.features.forEach(quantizeFeature);\n      break;\n\n    default:\n      quantizeGeometry(o);\n      break;\n  }\n  return o;\n}","map":{"version":3,"sources":["/Users/kyungjoon/react_pjt/edge-cloud-ui_current-working/node_modules/react-simple-maps/node_modules/d3-geo-projection/src/quantize.js"],"names":["o","digits","Error","quantizePoint","coordinates","toFixed","quantizePoints","forEach","quantizePolygon","quantizeGeometry","type","geometries","quantizeFeature","geometry","features"],"mappings":"AAAA,eAAe,UAASA,CAAT,EAAYC,MAAZ,EAAoB;AACjC,MAAI,EAAE,MAAMA,MAAM,GAAG,CAACA,MAAhB,KAA2BA,MAAM,IAAI,EAAvC,CAAJ,EAAgD,MAAM,IAAIC,KAAJ,CAAU,gBAAV,CAAN;;AAEhD,WAASC,aAAT,CAAuBC,WAAvB,EAAoC;AAClCA,IAAAA,WAAW,CAAC,CAAD,CAAX,GAAiB,CAACA,WAAW,CAAC,CAAD,CAAX,CAAeC,OAAf,CAAuBJ,MAAvB,CAAlB;AACAG,IAAAA,WAAW,CAAC,CAAD,CAAX,GAAiB,CAACA,WAAW,CAAC,CAAD,CAAX,CAAeC,OAAf,CAAuBJ,MAAvB,CAAlB;AACD;;AAED,WAASK,cAAT,CAAwBF,WAAxB,EAAqC;AACnCA,IAAAA,WAAW,CAACG,OAAZ,CAAoBJ,aAApB;AACD;;AAED,WAASK,eAAT,CAAyBJ,WAAzB,EAAsC;AACpCA,IAAAA,WAAW,CAACG,OAAZ,CAAoBD,cAApB;AACD;;AAED,WAASG,gBAAT,CAA0BT,CAA1B,EAA6B;AAC3B,QAAIA,CAAJ,EAAO,QAAQA,CAAC,CAACU,IAAV;AACL,WAAK,oBAAL;AAA2BV,QAAAA,CAAC,CAACW,UAAF,CAAaJ,OAAb,CAAqBE,gBAArB;AAAwC;;AACnE,WAAK,OAAL;AAAcN,QAAAA,aAAa,CAACH,CAAC,CAACI,WAAH,CAAb;AAA8B;;AAC5C,WAAK,YAAL;AAAmB,WAAK,YAAL;AAAmBE,QAAAA,cAAc,CAACN,CAAC,CAACI,WAAH,CAAd;AAA+B;;AACrE,WAAK,iBAAL;AAAwB,WAAK,SAAL;AAAgBI,QAAAA,eAAe,CAACR,CAAC,CAACI,WAAH,CAAf;AAAgC;;AACxE,WAAK,cAAL;AAAqBJ,QAAAA,CAAC,CAACI,WAAF,CAAcG,OAAd,CAAsBC,eAAtB;AAAwC;;AAC7D;AAAS;AANJ;AAQR;;AAED,WAASI,eAAT,CAAyBZ,CAAzB,EAA4B;AAC1BS,IAAAA,gBAAgB,CAACT,CAAC,CAACa,QAAH,CAAhB;AACD;;AAED,MAAIb,CAAJ,EAAO,QAAQA,CAAC,CAACU,IAAV;AACL,SAAK,SAAL;AAAgBE,MAAAA,eAAe,CAACZ,CAAD,CAAf;AAAoB;;AACpC,SAAK,mBAAL;AAA0BA,MAAAA,CAAC,CAACc,QAAF,CAAWP,OAAX,CAAmBK,eAAnB;AAAqC;;AAC/D;AAASH,MAAAA,gBAAgB,CAACT,CAAD,CAAhB;AAAqB;AAHzB;AAMP,SAAOA,CAAP;AACD","sourcesContent":["export default function(o, digits) {\n  if (!(0 <= (digits = +digits) && digits <= 20)) throw new Error(\"invalid digits\");\n\n  function quantizePoint(coordinates) {\n    coordinates[0] = +coordinates[0].toFixed(digits);\n    coordinates[1] = +coordinates[1].toFixed(digits);\n  }\n\n  function quantizePoints(coordinates) {\n    coordinates.forEach(quantizePoint);\n  }\n\n  function quantizePolygon(coordinates) {\n    coordinates.forEach(quantizePoints);\n  }\n\n  function quantizeGeometry(o) {\n    if (o) switch (o.type) {\n      case \"GeometryCollection\": o.geometries.forEach(quantizeGeometry); break;\n      case \"Point\": quantizePoint(o.coordinates); break;\n      case \"MultiPoint\": case \"LineString\": quantizePoints(o.coordinates); break;\n      case \"MultiLineString\": case \"Polygon\": quantizePolygon(o.coordinates); break;\n      case \"MultiPolygon\": o.coordinates.forEach(quantizePolygon); break;\n      default: return;\n    }\n  }\n\n  function quantizeFeature(o) {\n    quantizeGeometry(o.geometry);\n  }\n\n  if (o) switch (o.type) {\n    case \"Feature\": quantizeFeature(o); break;\n    case \"FeatureCollection\": o.features.forEach(quantizeFeature); break;\n    default: quantizeGeometry(o); break;\n  }\n\n  return o;\n}\n"]},"metadata":{},"sourceType":"module"}